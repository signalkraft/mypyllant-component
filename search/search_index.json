{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Home Assistant component that interfaces with the myVAILLANT API (and branded versions of it, such as the MiGo Link app from Saunier Duval &amp; Bulex). Uses the myPyllant Python library.</p>"},{"location":"#installation","title":"Installation","text":"<p>Note</p> <ol> <li>The developers are not affiliated with Vaillant, we take no responsibility for anything that happens to your devices because of this library</li> <li>This integration is not compatible with systems that use sensoAPP and multiMATIC</li> </ol> HACSManual <ol> <li>Install the Home Assistant Community Store (HACS)</li> <li>Search for myVAILLANT in HACS  Integrations and download it</li> <li>Restart Home Assistant</li> <li>Add myVaillant integration, or go to    Settings  Devices &amp; services  Add Integration</li> <li>Sign in with the email &amp; password you used in the myVAILLANT app (or MiGo app for Saunier Duval)</li> </ol> <p>Having problems? Open an issue.</p> <ol> <li>Download the latest release</li> <li>Extract the <code>custom_components</code> folder to your Home Assistant's config folder, the resulting folder structure should    be <code>config/custom_components/mypyllant</code></li> <li>Restart Home Assistant</li> <li>Add myVaillant integration, or go to    Settings  Devices &amp; services  Add Integration</li> <li>Sign in with the email &amp; password you used in the myVAILLANT app (or MiGo app for Saunier Duval)</li> </ol> <p>Having problems? Open an issue.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p> Climate Controls</p> <p>Supports climate &amp; hot water controls, as well as ventilation and circulation pumps</p> <p> Read more</p> </li> <li> <p> Set Modes &amp; Temperatures</p> <p>Control operating modes, target temperature, and presets such as holiday more or quick veto</p> <p> Read more</p> </li> <li> <p> Change Schedules</p> <p>Set the schedule for climate zones, water heaters, and circulation pumps  with a custom service or in the Home Assistant calendar</p> <p> Read more</p> </li> <li> <p> Track Data over Time</p> <p>Track sensor information of devices, such as temperature, humidity, operating mode, energy usage, or energy efficiency</p> <p> Read more</p> </li> <li> <p> Diagnostic Data</p> <p>See diagnostic information, such as flow temperature, firmware versions, or water pressure.  Even values that are not available in the app, such as the current heating curve.</p> <p> Read more</p> </li> <li> <p> Services &amp; Automations</p> <p>Custom services to set holiday mode or quick veto temperature overrides, and their duration</p> <p> Read more</p> </li> </ul> <p></p>"},{"location":"#tested-setups","title":"Tested Setups","text":"<ul> <li>Vaillant aroTHERM plus heatpump + sensoCOMFORT VRC 720 + sensoNET VR 921</li> <li>Vaillant ECOTEC PLUS boiler + VR940F + sensoCOMFORT</li> <li>Vaillant ECOTEC PLUS boiler + VRT380f + sensoNET</li> <li>Vaillant ECOTEC PLUS VCW20/1 boiler + sensoCOMFORT VRC 720 + sensoNET VR 921</li> <li>Vaillant ECOTEC PLUS 296/5-5 (R6) + sensoCOMFORT VRC 720/2 + VR 70 (2 circuits) + sensoNET VR 921</li> <li>Vaillant ecoVIT + VIH R/6 uniSTORE + VR920</li> <li>Saunier Duval DUOMAX F30 90 + MISET Radio + MiLink V3</li> <li>Bulex Thema Condens F30/35 + Red 5 + MiPro Sense + MiLink v3</li> </ul>"},{"location":"#options","title":"Options","text":"<p>After setting up the integration, you can configure it further in Settings  Devices &amp; Services  myVAILLANT  Configure.</p> <p>Warning</p> <p>The integration fetches limited data by default, to avoid running into quota errors, or generating unnecessary errors (when trying to fetch data that' not available for your system).</p> <p>If you have data that's available in the myVAILLANT app, but not the integration, you probably need to modify the integration options starting with <code>Fetch XYZ</code>.</p>"},{"location":"#seconds-between-updates","title":"Seconds between updates","text":"<p>Wait interval between updating (most) sensors. The energy data and efficiency sensors are controlled by the next option. Setting this too low can cause \"quota exceeded\" errors.</p> <p>You should restart Home Assistant after changing this setting.</p> <p> Default is 1800 seconds.</p>"},{"location":"#seconds-between-energy-data-updates","title":"Seconds between energy data updates","text":"<p>Wait interval between updating sensors with hourly data. Default is off, because querying for energy data can get you blocked by Vaillant quite easily (\"quota exceeded\" errors).</p> <p>Most users seem to be OK with 7200s (2 hours) or more.</p> <p>You can also schedule your own updates with an automation, for example once a day just before midnight:</p> <pre><code>description: \"Update myVAILLANT energy data at midnight\"\nmode: single\ntriggers:\n  - trigger: time\n    at: \"23:59:00\"\nconditions: []\nactions:\n    - action: homeassistant.update_entity\n      metadata: {}\n      data:\n        entity_id:\n          - sensor.home_heating_energy_efficiency\n</code></pre> <p>You only need to update one of the energy entities, all of the other ones will automatically update as well. To reduce API queries and avoid getting blocked, you should disable energy entities in HA that you are not interested in.</p> <p>You should restart Home Assistant after changing this setting.</p> <p> Default is off.</p>"},{"location":"#delay-in-seconds-before-refreshing-data-after-updates","title":"Delay in seconds before refreshing data after updates","text":"<p>How long to wait between making a request (i.e. setting target temperature) and refreshing data. The Vaillant API takes some time to return the updated values. Setting this too low will return the old values.</p> <p> Default is 5 seconds.</p>"},{"location":"#default-duration-in-hours-for-quick-veto","title":"Default duration in hours for quick veto","text":"<p>When setting the temperature with the climate controls, the integration uses the \"quick veto\" feature of the myVAILLANT app by default.</p> <p>With this option you can set for how long the temperature should stay set, before returning to the default value.</p> <p> Default is 3 hours.</p>"},{"location":"#default-duration-in-days-for-away-mode","title":"Default duration in days for away mode","text":"<p>When the away mode preset is activated, this duration is used to for the end date.</p> <p> Default is 365 days.</p>"},{"location":"#default-temperature-setpoint-for-away-mode","title":"Default temperature setpoint for away mode","text":"<p>When away mode is activated without a temperature (for example with the away mode switch), this value is set for all zones.</p> <p> Default is 10.0\u00b0C.</p>"},{"location":"#temperature-controls-overwrite-time-program-instead-of-setting-quick-veto","title":"Temperature controls overwrite time program instead of setting quick veto","text":"<p>When raising or lowering the desired temperature in the myVAILLANT app, it sets a quick veto mode for a limited time with that new temperature, if the zone is in time controlled mode. If you want to permanently change the desired temperature, you need to update the time schedule.</p> <p>By default, this integration has the same behavior. But when enabling this option, the Home Assistant climate controls instead overwrite the temperatures set in the time schedule with the new value.</p> <p> Default is off.</p> <p>Note</p> <p>If quick veto is active, the climate controls will always set the quick veto temperature.</p>"},{"location":"#fetch-real-time-statistics-not-supported-on-every-system","title":"Fetch real-time statistics (not supported on every system)","text":"<p>Fetches real-time statistics from the system. This includes on/off cycles and operation time. If you see 404 errors in your logs after enabling this, your system doesn't support this data. It's best to turn it off again.</p> <p> Default is off.</p>"},{"location":"#fetch-real-time-power-usage-not-supported-on-every-system","title":"Fetch real-time power usage (not supported on every system)","text":"<p>Fetches real-time power usage of the system. If you see 404 errors in your logs after enabling this, your system doesn't support this data. It's best to turn it off again.</p> <p> Default is off.</p>"},{"location":"#fetch-system-connection-status","title":"Fetch system connection status","text":"<p>Fetches connection status of the system (Connected / Offline).</p> <p> Default is off.</p>"},{"location":"#fetch-diagnostic-trouble-codes","title":"Fetch diagnostic trouble codes","text":"<p>Fetches diagnostic trouble codes of the system, for each connected &amp; supported device.</p> <p> Default is off.</p>"},{"location":"#fetch-ambisense-capability","title":"Fetch Ambisense Capability","text":"<p>Fetches information, whether the system has Ambisense capabilities.</p> <p> Default is off.</p>"},{"location":"#fetch-ambisense-room-thermostats-not-supported-on-every-system","title":"Fetch Ambisense Room Thermostats (not supported on every system)","text":"<p>Fetches Ambisense room thermostat data. If you see 404 errors in your logs after enabling this, your system doesn't support this data. It's best to turn it off again.</p> <p> Default is off.</p>"},{"location":"#fetch-eebus-data","title":"Fetch EEBUS Data","text":"<p>Fetches information whether EEBUS is available or not.</p> <p> Default is off.</p>"},{"location":"#fetch-energy-management-data","title":"Fetch Energy Management Data","text":"<p>Fetches energy management data from EEBUS.</p> <p> Default is off.</p>"},{"location":"#country","title":"Country","text":"The country you registered your myVAILLANT account in. The list of options is limited to known supported countries."},{"location":"#brand","title":"Brand","text":"Brand of your HVAC equipment and app, pick Saunier Duval if you use the MiGo Link app."},{"location":"#supported-brands-countries","title":"Supported Brands &amp; Countries","text":"<p>Missing a Country?</p> <p>If a country is missing, please open an issue or contribute a new country to the myPyllant library.</p> <ul> <li>Vaillant<ul> <li>Albania</li> <li>Austria</li> <li>Belgium</li> <li>Bulgaria</li> <li>Croatia</li> <li>Czechia</li> <li>Denmark</li> <li>Estonia</li> <li>Finland</li> <li>France</li> <li>Georgia</li> <li>Germany</li> <li>Greece</li> <li>Hungary</li> <li>Italy</li> <li>Latvia</li> <li>Lithuania</li> <li>Luxembourg</li> <li>Netherlands</li> <li>Norway</li> <li>Poland</li> <li>Portugal</li> <li>Romania</li> <li>Serbia</li> <li>Slovakia</li> <li>Slovenia</li> <li>Spain</li> <li>Sweden</li> <li>Switzerland</li> <li>Ukraine</li> <li>United Kingdom</li> <li>Uzbekistan</li> </ul> </li> <li>Saunier Duval<ul> <li>Austria</li> <li>Czechia</li> <li>Finland</li> <li>France</li> <li>Greece</li> <li>Hungary</li> <li>Italy</li> <li>Lithuania</li> <li>Poland</li> <li>Portugal</li> <li>Romania</li> <li>Slovakia</li> <li>Spain</li> </ul> </li> <li>Bulex<ul> <li>Does not support country selection, just leave the option empty</li> </ul> </li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":""},{"location":"#lack-of-test-data-for-different-systems","title":"Lack of Test Data for Different Systems","text":"<p>Your HVAC system might differ from the ones in Tested Setups above. If you don't see any entities, or get an error during setup, please check Debugging and create an issue. With debugging enabled, there's a chance to find the culprit in the data returned by the myVAILLANT API and fix it.</p>"},{"location":"#getting-quota-exceeded-errors","title":"Getting Quota Exceeded Errors","text":"<p>If you are getting \"Quota Exceeded\" errors, you have a few options:</p> <ol> <li>Decrease update interval in the integration options. 1800s for live data updates and 7200s for energy data seems save, based on user feedback</li> <li>Disable energy and efficiency sensor that you don't need. Disabled sensors are skipped in the update, and reduce API calls</li> <li>Invite another user in the myVAILLANT app and use that one for the integration. This way at least queries from the mobile app run on a separate account</li> </ol> <p>There's no clear documentation from Vaillant about which API endpoints have quotas, what these quotas are, or how to avoid them.</p>"},{"location":"#vaillant-api-is-occasionally-unavailable","title":"Vaillant API is occasionally unavailable","text":"<p>The API this integration uses sometimes goes down. Before reporting an issue, check if the myVAILLANT app works normally. If it doesn't, there's nothing we can do about it.</p>"},{"location":"#some-features-that-are-available-on-the-controller-or-in-the-maintenance-settings-are-not-available","title":"Some features that are available on the controller or in the maintenance settings are not available","text":"<p>If you would like to request a new feature, please check that it's available in the myVAILLANT app first. Some data (for example quiet mode or legionella protection) are not available in the app, and therefore can't be supported by this integration.</p>"},{"location":"#the-modes-in-home-assistant-and-the-myvaillant-app-dont-match","title":"The modes in Home Assistant and the myVAILLANT app don't match","text":"<p>Home Assistant has certain pre-defined modes, that can't be changed. Check the mapping of modes between Home Assistant and myVAILLANT.</p>"},{"location":"#energy-efficiency-sensors-are-delayed-incomplete-behave-oddly-around-midnight","title":"Energy &amp; Efficiency Sensors are delayed / incomplete / behave oddly around midnight","text":"<p>How Vaillant reports energy data, and how Home Assistant deals with sensor data is not a good match:</p> <ul> <li>Vaillant's API provides energy data in hourly increments, some time after the full hour has passed (let's say at 10:30am for the energy data from 9-10am)</li> <li>This integration fetches energy data every hour, for the current day, up to the current time<ul> <li>Depending on when your HA schedules this hourly update, it may happen right after Vaillant provides the new hourly data, or almost an hour later</li> <li>Home Assistant doesn't support setting a past date for a sensor reading, the value is always displayed at the time when it was saved</li> <li>Home Assistant also doesn't let you pick when to schedule the hourly update exactly, it depends on when the integration was initialized</li> <li>Data for the whole day is fetched, so that the total is correct even if the API is temporarily unavailable, or the integration misses an hour window for some other reason </li> </ul> </li> <li>Worst case, you end up with a 30min delay from Vaillant and a 59min delay from the integration: Your energy data from 9-10am will show up at 11:29am. Best case is probably around 10:30am.</li> <li>After midnight, the integration will fetch data for the new day, which will be empty until the first full hour + delay has passed<ul> <li>If you have new energy data between 11pm and midnight, it won't show up in your total for the previous day</li> </ul> </li> </ul> <p>Home Assistant would need to allow setting a timestamp with each new energy value, to improve this situation. The delay would still be there, but at least the values would be displayed at the correct time.</p> <p>You can lower the update interval for fetching energy data, to minimize the delay between Vaillant's updates and HA. See Options. But it's not recommended, since it's a lot of data to fetch and Vaillant may ban you temporarily with 'quota exceeded' errors.</p> <p>To fix data loss around midnight, the integration could fetch a longer period of time (for example a whole month). But then the sensor would no longer show a daily total, which would potentially mess with users' setups. The change from daily to monthly would also show up as a strange spike of energy usage when the update is done. </p>"},{"location":"1-automations/","title":"Automations &amp; Cards","text":""},{"location":"1-automations/#automations-cards","title":"Automations &amp; Cards","text":""},{"location":"1-automations/#legionella-protection","title":"Legionella Protection<sup>1</sup>","text":"<p>With the Home Assistant component, more flexible legionella protection is possible. You can tweak the time condition or the target temperature(s).</p> <pre><code>alias: Legionella Protection\ndescription: \"\"\ntrigger:\n  - platform: time\n    at: \"10:00:00\"\ncondition:\n  - condition: time\n    weekday:\n      - sun  # (1)\naction:\n  - service: water_heater.set_temperature\n    data:\n      temperature: 75 # (2)\n    target:\n      entity_id: water_heater.domestic_hot_water_0\n  - delay:\n      hours: 8 # (3)\n      minutes: 0\n      seconds: 0\n      milliseconds: 0\n  - service: water_heater.set_temperature\n    data:\n      temperature: 50 # (4)\n    target:\n      entity_id: water_heater.domestic_hot_water_0\nmode: single\n</code></pre> <ol> <li>You can customize the frequency and weekday here,    see Time condition documentation</li> <li>Here you can set the target temperature for legionella protection</li> <li>This is the duration. Make sure it covers the time period where your water heater is turned on</li> <li>This should be your regular water temperature</li> </ol>"},{"location":"1-automations/#turning-off-water-heater-with-climate-away-mode","title":"Turning off Water Heater with Climate Away Mode","text":"<p>With these two automations, your water heater turns on and off with the away mode of your climate entity.</p> <pre><code>alias: Water heater off during Zone 1 away mode\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - climate.home_zone_1_circuit_0_climate # (1)\n    attribute: preset_mode\n    to: away\ncondition: [ ]\naction:\n  - service: water_heater.set_operation_mode\n    target:\n      entity_id:\n        - water_heater.home_domestic_hot_water_0 # (2)\n    data:\n      operation_mode: 'OFF'\nmode: single\n</code></pre> <ol> <li>Pick your climate entity</li> <li>Pick your water heater entity</li> </ol> <pre><code>alias: myVAILLANT DHW on after ending away mode\ndescription: \"\"\ntrigger:\n  - platform: state\n    entity_id:\n      - climate.home_zone_1_circuit_0_climate # (1)\n    attribute: preset_mode\n    from: away\ncondition: [ ]\naction:\n  - service: water_heater.set_operation_mode\n    target:\n      entity_id:\n        - water_heater.home_domestic_hot_water_0 # (2)\n    data:\n      operation_mode: TIME_CONTROLLED\nmode: single\n</code></pre> <ol> <li>Pick your climate entity</li> <li>Pick your water heater entity</li> </ol>"},{"location":"1-automations/#control-heating-schedule-based-on-solar-power","title":"Control Heating Schedule based on Solar Power","text":"<p>This automation delays heating until after sunrise on sunny days, to make the most of solar power. You could also use your water heater schedule, to boost tank temperature at the end of the day when solar power is still available.</p> <pre><code>alias: myVAILLANT Delay Heating on Sunny Days\ndescription: \"\"\ntrigger:\n  - platform: calendar\n    event: start\n    offset: \"0:30:0\"\n    entity_id: calendar.home_zone_1_circuit_0_heating_schedule # (1)\ncondition:\n  - condition: numeric_state\n    entity_id: sensor.openweathermap_forecast_cloud_coverage # (2)\n    below: 50\n  - condition: sun\n    before: sunrise\naction:\n  - service: mypyllant.set_holiday\n    target:\n      entity_id: climate.home_zone_1_circuit_0_climate # (3)\n    data:\n      end: \"{{ (as_timestamp(states.sensor.sun_next_rising.state) + 1.5 * 3600) | timestamp_local }}\" # (4)\nmode: single\n</code></pre> <ol> <li>Pick your calendar entity. The offset makes sure that a little bit of heating still happens at the scheduled start</li> <li>Uses OpenWeatherMap to determine forecasted cloud coverage, only triggers if cloud coverage is below 50%</li> <li>Pick your climate entity</li> <li>Delays heating until 1,5h after sunrise</li> </ol>"},{"location":"1-automations/#climate-control-cards-with-away-mode-datepickers","title":"Climate Control Cards with Away Mode Datepickers","text":"<p>This is a sample card configuration with climate &amp; water heater controls, as well as a conditional switch for away mode that shows date pickers when away mode is enabled. You probably need to replace <code>home</code> and <code>zone_1</code> with your entity names.</p> <p></p> <p>You need the Mushroom Cards addon.</p> <pre><code>type: vertical-stack\ncards:\n  - type: custom:mushroom-chips-card\n    chips:\n      - type: entity\n        entity: binary_sensor.home_online_status\n      - type: entity\n        entity: sensor.home_zone_1_circuit_0_heating_state\n        icon: mdi:air-purifier\n      - type: entity\n        entity: sensor.home_zone_1_circuit_0_current_temperature\n      - type: entity\n        entity: sensor.home_system_water_pressure\n  - type: custom:mushroom-climate-card\n    entity: climate.home_zone_1_circuit_0_climate\n    fill_container: false\n    hvac_modes:\n      - auto\n      - heat_cool\n      - 'off'\n    show_temperature_control: false\n    collapsible_controls: false\n    icon: mdi:heat-pump\n    tap_action:\n      action: more-info\n    secondary_info: state\n  - type: custom:mushroom-entity-card\n    entity: switch.home_holiday_duration_remaining\n    tap_action:\n      action: toggle\n    fill_container: false\n    layout: horizontal\n  - type: conditional\n    conditions:\n      - condition: state\n        entity: switch.home_holiday_duration_remaining\n        state: 'on'\n    card:\n      type: entities\n      entities:\n        - entity: datetime.home_away_mode_start_date\n        - entity: datetime.home_away_mode_end_date\n  - type: horizontal-stack\n    cards:\n      - type: custom:mushroom-entity-card\n        entity: water_heater.home_domestic_hot_water_0\n        name: Hot Water\n        icon: mdi:thermometer-water\n      - type: custom:mushroom-entity-card\n        entity: switch.home_domestic_hot_water_0_boost\n        name: Hot Water Boost\n        icon: mdi:thermometer-chevron-up\n        tap_action:\n          action: toggle\n</code></pre> <ol> <li> <p>Contributed by CommanderROR in the Home Assistant Community \u21a9</p> </li> </ol>"},{"location":"2-entities/","title":"Entities","text":""},{"location":"2-entities/#entities","title":"Entities","text":"<p>You can expect these entities, although names will vary based on your home name (here \"Home\"), installed devices (in this example \"aroTHERM plus\" and \"Hydraulic Station\"), or the naming of your heating zones (in this case \"Zone 1\"):</p>"},{"location":"2-entities/#sample-entities","title":"Sample Entities","text":"Entity Unit Class Sample Home Trouble Codes problem off Home Online Status connectivity on Home Firmware Update Required update off Home Firmware Update Enabled on Home EEBUS Enabled on Home EEBUS Capable on Home Circuit 0 Cooling Allowed on Home Zone 1 (Circuit 0) Manual Cooling Active off Home Zone 1 (Circuit 0) on Home Zone 1 (Circuit 0) on Home Domestic Hot Water 0 on Circulating Water in Home Domestic Hot Water 0 off Home Zone 1 (Circuit 0) Climate auto Home Away Mode Start Date unknown Home Away Mode End Date unknown Home Manual Cooling Start Date unknown Home Manual Cooling End Date unknown Home Holiday Duration Remaining d 0 Home Manual Cooling Duration d 0 Home Zone 1 (Circuit 0) Quick Veto Duration h 2 Home Circuit 0 Heating Curve 1.2733452 Home Circuit 0 Heat Demand Limited by Outside Temperature \u00b0C 18.0 Home Circuit 0 Min Flow Temperature Setpoint \u00b0C 32.0 Vaillant API Request Count 51 Home Outdoor Temperature \u00b0C temperature 17.3 Home System Water Pressure bar pressure 1.5 Home Firmware Version 0357.40.35 Home Zone 1 (Circuit 0) Desired Temperature \u00b0C temperature 0.0 Home Zone 1 (Circuit 0) Desired Heating Temperature \u00b0C temperature 0.0 Home Zone 1 (Circuit 0) Desired Cooling Temperature \u00b0C temperature 25.0 Home Zone 1 (Circuit 0) Current Temperature \u00b0C temperature 21.5 Home Zone 1 (Circuit 0) Humidity % humidity 62.0 Home Zone 1 (Circuit 0) Heating Operating Mode Time Controlled Home Zone 1 (Circuit 0) Heating State Idle Home Zone 1 (Circuit 0) Current Special Function Quick Veto Home Circuit 0 State STANDBY Home Circuit 0 Current Flow Temperature \u00b0C temperature 41.0 Home Circuit 0 Heating Curve 1.27 Home Domestic Hot Water 0 Tank Temperature \u00b0C temperature 51.5 Home Domestic Hot Water 0 Setpoint \u00b0C temperature 52.0 Home Domestic Hot Water 0 Operation Mode Time Controlled Home Domestic Hot Water 0 Current Special Function Regular Home Heating Energy Efficiency 4.9 Home Device 0 aroTHERM plus Heating Energy Efficiency 4.9 Home Device 0 aroTHERM plus Consumed Electrical Energy Cooling Wh energy 0.0 Home Device 0 aroTHERM plus Consumed Electrical Energy Domestic Hot Water Wh energy 3000.0 Home Device 0 aroTHERM plus Consumed Electrical Energy Heating Wh energy 4000.0 Home Device 0 aroTHERM plus Earned Environment Energy Cooling Wh energy 0.0 Home Device 0 aroTHERM plus Earned Environment Energy Domestic Hot Water Wh energy 9000.0 Home Device 0 aroTHERM plus Earned Environment Energy Heating Wh energy 18000.0 Home Device 0 aroTHERM plus Heat Generated Heating Wh energy 22000.0 Home Device 0 aroTHERM plus Heat Generated Domestic Hot Water Wh energy 12000.0 Home Device 0 aroTHERM plus Heat Generated Cooling Wh energy 0.0 Home Device 1 Hydraulic Station Heating Energy Efficiency unknown Home Device 1 Hydraulic Station Consumed Electrical Energy Domestic Hot Water Wh energy 0.0 Home Device 1 Hydraulic Station Consumed Electrical Energy Heating Wh energy 0.0 Home Away Mode off Home EEBUS on Home Manual Cooling off Home Domestic Hot Water 0 Boost off Home Zone 1 (Circuit 0) Ventilation Boost off Home Domestic Hot Water 0 Time Controlled"},{"location":"2-entities/#climate-entities","title":"Climate Entities","text":"<p>Home Assistant's built-in climate modes differ from Vaillant's. The following table shows the mapping for zones:</p> VRC720 ControllerVRC700 Controller Home Assistant Mode Home Assistant Preset Vaillant Mode  Off  No Preset Off  Auto  No Preset Time Controlled Mode  Auto  Eco Preset Eco mode  Heat / Cool  No Preset Manual Mode  Auto Heat / Cool  Away Preset Away Mode  Auto Heat / Cool  Boost Preset Quick Veto Mode  Auto Heat / Cool  Sleep Preset Off Home Assistant Mode Home Assistant Preset Vaillant Mode  Off  No Preset Off  Auto  No Preset Auto Mode  Auto  Home Preset Day Mode  Auto  Eco Preset Night Mode"},{"location":"2-entities/#ambisense-room-thermostats","title":"Ambisense Room Thermostats","text":"<p>There are separate climate entities for Ambisense room thermostats (only supported on VRC700 controllers):</p> Home Assistant Mode Home Assistant Preset Vaillant Mode  Off  No Preset Off  Auto  No Preset Auto Mode  Heat / Cool  No Preset Manual Mode  Auto Heat / Cool  Boost Preset Quick Veto Mode"},{"location":"2-entities/#calendar-entities","title":"Calendar Entities","text":"<p>Each zone and water heater has a calendar for changing the heating schedule. Water heaters also have a calendar for  the circulation pump.</p> <p>In each calendar, you can:</p> <ul> <li>Create new time slots (set a target temperature as the event summary)</li> <li>Update existing time slots by changing start time, end time, weekdays, or the target temperature in the event summary</li> <li>Delete time slots on a specific weekday</li> </ul> <p>Note</p> <p>Make sure to select weekly repetition whenever you create, update, or delete events.</p> <p>Individual events can't be edited, only the whole weekly schedule.</p>"},{"location":"2-entities/#extra-state-attributes","title":"Extra State Attributes","text":"<p>Some entities come with extra state attributes for debugging and advanced usage. Your attributes may be different, depending on your devices.</p>"},{"location":"2-entities/#home-sensor","title":"Home Sensor","text":"<pre><code>migration_finished_at: redacted\nonline_state: ONLINE\ncooling_start_temperature: 15\ncontinuous_heating_start_setpoint: -26\nalternative_point: -21\nheating_circuit_bivalence_point: -10\ndhw_bivalence_point: -7\nautomatic_cooling_on_off: false\nadaptive_heating_curve: true\ndhw_maximum_loading_time: 60\ndhw_hysteresis: 5\ndhw_flow_setpoint_offset: 25\ncontinuous_heating_room_setpoint: 20\nhybrid_control_strategy: BIVALENCE_POINT\nmax_flow_setpoint_hp_error: 25\ndhw_maximum_temperature: 80\nmaximum_preheating_time: 0\nparalell_tank_loading_allowed: false\noutdoor_temperature: 20.097656\noutdoor_temperature_average24h: 20.464844\nsystem_water_pressure: 1.7\nenergy_manager_state: STANDBY\nsystem_off: false\ncontroller_type: VRC720\nsystem_scheme: 8\nbackup_heater_type: CONDENSING\nbackup_heater_allowed_for: DHW_AND_HEATING\ntemporary_allow_backup_heater: DISABLED\nmodule_configuration_v_r71: 3\nenergy_provide_power_cut_behavior: DISABLE_HEATPUMP_AND_BACKUP_HEATER\nsmart_photovoltaic_buffer_offset: 10\nexternal_energy_management_activation: false\nenergy_management: \n  energy_manager:\n    available: false\n    compatible: false\n  energy_management_status:\n    thermal_storage:\n      domestic_hot_water:\n        available: false\n        selected: false\n      heating_buffer_cylinder:\n        available: false\n        selected: true\neebus: \n  ski: redacted\n  brand: Vaillant\n  type: Gateway\n  model: VR921\n  spine_enabled: false\n  spine_enabled_status: DETERMINED\n  pine_capable: true\n</code></pre>"},{"location":"2-entities/#control-error-binary-sensor","title":"Control Error Binary Sensor","text":"<pre><code>diagnostic_trouble_codes:\n  - serial_number:\n    article_number: '0020260962'\n    codes: [ ]\n  - serial_number:\n    article_number: '0010021118'\n    codes: [ ]\n  - serial_number:\n    article_number: '0010023609'\n    codes: [ ]\n  - serial_number:\n    article_number: '0020260914'\n    codes: [ ]\n</code></pre>"},{"location":"2-entities/#climate-entity","title":"Climate Entity","text":"<pre><code>hvac_modes: off, heat_cool, auto\nmin_temp: 7\nmax_temp: 35\npreset_modes: boost, none, away, sleep\ncurrent_temperature: 21.5\ntemperature: 0\ncurrent_humidity: 53\npreset_mode: none\ntime_program_heating:\n  extra_fields: { }\n  monday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  tuesday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  wednesday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  thursday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  friday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  saturday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  sunday:\n    - extra_fields: { }\n      start_time: 420\n      end_time: 1290\n      setpoint: 21\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 12\n    setpoint_required_per_slot: true\n\nquick_veto_start_date_time: null\nquick_veto_end_date_time: null\n</code></pre>"},{"location":"2-entities/#circuit-state-sensor","title":"Circuit State Sensor","text":"<pre><code>room_temperature_control_mode: THERMOSTAT_FUNCTION\ncooling_flow_temperature_minimum_setpoint: 20\nheating_circuit_type: DIRECT_HEATING_CIRCUIT\nheating_circuit_flow_setpoint: 0\nheating_circuit_flow_setpoint_excess_offset: 0\nheat_demand_limited_by_outside_temperature: 19\n</code></pre>"},{"location":"2-entities/#domestic-hot-water-entity","title":"Domestic Hot Water Entity","text":"<pre><code>min_temp: 35\nmax_temp: 70\noperation_list: Manual, Time Controlled, Off, Cylinder Boost\ncurrent_temperature: 44\ntemperature: 50\ntarget_temp_high: null\ntarget_temp_low: null\noperation_mode: Time Controlled\ntime_program_dhw:\n  extra_fields: { }\n  monday:\n    - extra_fields: { }\n      start_time: 330\n      end_time: 1260\n  tuesday:\n    - extra_fields: { }\n      start_time: 330\n      end_time: 1260\n  wednesday:\n    - extra_fields: { }\n      start_time: 330\n      end_time: 1260\n  thursday:\n    - extra_fields: { }\n      start_time: 330\n      end_time: 1260\n  friday:\n    - extra_fields: { }\n      start_time: 330\n      end_time: 1260\n  saturday:\n    - extra_fields: { }\n      start_time: 450\n      end_time: 1260\n  sunday:\n    - extra_fields: { }\n      start_time: 450\n      end_time: 1260\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 3\n    setpoint_required_per_slot: false\n\ntime_program_circulation_pump:\n  extra_fields: { }\n  monday: [ ]\n  tuesday: [ ]\n  wednesday: [ ]\n  thursday: [ ]\n  friday: [ ]\n  saturday: [ ]\n  sunday: [ ]\n  meta_info:\n    min_slots_per_day: 0\n    max_slots_per_day: 3\n    setpoint_required_per_slot: false\n</code></pre>"},{"location":"2-services/","title":"Services","text":""},{"location":"2-services/#services","title":"Services","text":"<p>There are custom services for almost every functionality of the myVAILLANT app:</p> Name Description Target Fields Set quick veto Sets quick veto temperature with optional duration climate Temperature, Duration Set manual mode setpoint Sets temperature for manual mode climate Temperature, Type Cancel quick veto Cancels quick veto temperature and returns to normal schedule / manual setpoint climate Set holiday Set holiday / away mode with start / end or duration climate Start Date, End Date, Duration, Setpoint Cancel Holiday Cancel holiday / away mode climate Set Time Program Updates the time program for a zone or room climate Type, Time Program Set Zone Time Program (deprecated) Deprecated, use \"Set Time Program\" instead climate Type, Time Program Set Zone Operating mode Same as setting HVAC mode, but allows setting heating or cooling climate Operating Mode, Operating Type Set Water Heater Time Program Updates the time program for a water heater water_heater Time Program Set Water Heater Circulation Time Program Updates the time program for the circulation pump of a water heater water_heater Time Program Export Data Exports data from the mypyllant library Data, Data Resolution, Start Date, End Date Generate Test Data Generates test data for the mypyllant library and returns it as YAML Export Yearly Energy Reports Exports energy reports in CSV format per year Year <p>Additionally, there are home assistant's built in services for climate controls, water heaters, and switches.</p> <p>Search for \"myvaillant\" in Developer Tools  Services in your Home Assistant instance to get the full list plus an interactive UI.</p> <p></p> <p></p>"},{"location":"2-services/#exporting-data","title":"Exporting Data","text":"<ul> <li>mypyllant.report for   exporting yearly energy reports (in CSV format)</li> <li>mypyllant.export for   exporting raw data of your system</li> <li>mypyllant.generate_test_data   for generating test data to contribute to the myPyllant library</li> </ul>"},{"location":"2-services/#setting-a-time-program","title":"Setting a Time Program","text":"<p>The following services can be used to set time programs:</p> <ul> <li>mypyllant.set_time_program   for climate temperature schedule (requires an additional <code>program_type</code> for zone climate)</li> <li>mypyllant.set_dhw_time_program   for water heater temperature schedule</li> <li>mypyllant.set_dhw_circulation_time_program   for circulation pump schedule on water heaters</li> </ul> <p>You can look up your current time programs in the developer states view under attributes for your zones and water heater.</p> <p>Times in the time program are given in minutes since midnight in UTC.</p> <p>You can also use the calendar UI to change time programs.</p> <p>Disabling a time window</p> <p>You can delete all time windows on a day by sending an empty list, for example <code>monday: []</code>.</p> Zone ClimateAmbisense ClimateWater HeaterCirculation Pump <pre><code>service: mypyllant.set_time_program\ndata:\n  program_type: heating\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    thursday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    friday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    saturday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\n    sunday:\n      - start_time: 420\n        end_time: 1290\n        setpoint: 20\ntarget:\n  entity_id: climate.home_zone_1_circuit_0_climate\n</code></pre> <pre><code>service: mypyllant.set_time_program\ndata:\n  time_program:\n    monday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    tuesday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    wednesday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    thursday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    friday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    saturday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\n    sunday:\n      - startTime: 0\n        temperatureSetpoint: 20\n      - startTime: 360\n        temperatureSetpoint: 19\n      - startTime: 1260\n        temperatureSetpoint: 20\ntarget:\n  entity_id: climate.home_room_1_climate\n</code></pre> <pre><code>service: mypyllant.set_dhw_time_program\ndata:\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n    thursday:\n      - start_time: 420\n        end_time: 1290\n    friday:\n      - start_time: 420\n        end_time: 1290\n    saturday:\n      - start_time: 420\n        end_time: 1290\n    sunday:\n      - start_time: 420\n        end_time: 1290\ntarget:\n  entity_id: water_heater.home_domestic_hot_water_0\n</code></pre> <pre><code>service: mypyllant.set_dhw_circulation_time_program\ndata:\n  time_program:\n    monday:\n      - start_time: 420\n        end_time: 1290\n    tuesday:\n      - start_time: 420\n        end_time: 1290\n    wednesday:\n      - start_time: 420\n        end_time: 1290\n    thursday:\n      - start_time: 420\n        end_time: 1290\n    friday:\n      - start_time: 420\n        end_time: 1290\n    saturday:\n      - start_time: 420\n        end_time: 1290\n    sunday:\n      - start_time: 420\n        end_time: 1290\ntarget:\n  entity_id: water_heater.home_domestic_hot_water_0\n</code></pre>"},{"location":"3-contributing/","title":"Contributing","text":""},{"location":"3-contributing/#contributing","title":"Contributing","text":""},{"location":"3-contributing/#debugging","title":"Debugging","text":"<p>When debugging or reporting issues, turn on debug logging by adding this to your <code>configuration.yaml</code> and restarting Home Assistant:</p> <pre><code>logger:\n  default: warning\n  logs:\n    custom_components.mypyllant: debug\n    myPyllant: debug\n</code></pre> <p>Then you can check for errors in System  Logs and attach the logs when creating an issue.</p> <p>If you would like to see a value added to the integration, check if it's available when you generate test data.</p>"},{"location":"3-contributing/#contributing-test-data","title":"Contributing Test Data","text":"<p>Because the myVAILLANT API isn't documented, you can help the development of this library by contributing test data:</p> Home Assistant ServiceShellDocker <p>Go to Developer Tools  Services and select <code>mypyllant.generate_test_data</code>. Then call the service and copy the resulting output.</p> <p></p> <pre><code>uv run -m myPyllant.tests.generate_test_data -h\nuv run -m myPyllant.tests.generate_test_data username password brand --country country\n</code></pre> <pre><code>docker run -v $(pwd)/test_data:/build/src/myPyllant/tests/json -ti ghcr.io/signalkraft/mypyllant:latest python3 -m myPyllant.tests.generate_test_data username password brand --country country\n</code></pre> <p>With docker, the results will be put into <code>test_data/</code>.</p> <p>You can then either create a PR with the created folder, or zip it and attach it to an issue.</p>"},{"location":"3-contributing/#contributing-to-the-ha-component","title":"Contributing to the HA Component","text":"<p>Warning</p> <p>You need at least Python 3.13 and uv installed</p> <p>Fork and clone the mypyllant-component repository, then from within the directory run:</p> <pre><code>uv sync\nuv tool install pre-commit --with pre-commit-uv\npre-commit install\n# Make your changes\ngit commit -m ...  # Code formatting, analysis, and tests are run automatically before the commit\n</code></pre> <p>If you also need to modify the underlying myPyllant library, clone &amp; install it in editable mode in <code>mypyllant-component</code>:</p> <pre><code># From within the mypyllant-component directory\ngit clone https://github.com/signalkraft/myPyllant.git ../myPyllant\nuv pip install -e ../myPyllant\n# Run with --no-sync, or uv will remove the local package again\nuv run --no-sync pytest\n</code></pre>"},{"location":"3-contributing/#vscode-dev-container","title":"VSCode Dev Container","text":"<p>There's also a VSCode dev container available in <code>.devcontainer.json</code>, provided by github.com/ml1nk.</p>"},{"location":"3-contributing/#testing-in-docker","title":"Testing in Docker","text":"<p>To test your changes, you can spin up a quick Docker environment:</p> <ol> <li>Follow the installation steps above</li> <li>Copy <code>.env.sample</code> to <code>.env</code> and add your credentials in the new file</li> <li>Run <code>docker compose up</code></li> </ol> <p>After HA started, open http://localhost:8123 in your browser and sign in with user <code>test</code> and password <code>test</code>.</p> <p>The integration should be configured and show entities on the default dashboard.</p> <p></p>"},{"location":"3-contributing/#contributing-to-the-underlying-mypyllant-library","title":"Contributing to the underlying myPyllant library","text":"<p>Warning</p> <p>You need at least Python 3.13 and uv installed</p> <p>Fork and clone the myPyllant repository, then from within the directory run:</p> <pre><code>uv sync\nuv tool install pre-commit --with pre-commit-uv\npre-commit install\n# Make your changes\ngit commit -m ...  # Code formatting, analysis, and tests are run automatically before the commit\n</code></pre>"},{"location":"3-contributing/#supporting-new-countries","title":"Supporting new Countries","text":"<p>The myVAILLANT app uses Keycloak and OIDC for authentication, with a realm for each country and brand.</p> <p>To find the correct URL for a new country:</p> <ol> <li>Log out in the myVAILLANT app</li> <li>Open the login page in the app. If it directly logs you in without showing a login form, you may need to log out in your mobile browser. For Vaillant in Germany on https://myvaillantweb.de/</li> <li>Share the login URL in a new issue, but remove everything after <code>/auth</code></li> <li>If you can't find the URL or an option to share, look for a way to open the page in your default browser and share from there</li> </ol> <p>There is also a script to check which countries are supported, based on a list of all country names:</p> <pre><code>uv run -m myPyllant.tests.find_countries\n</code></pre> <p>Copy the resulting dictionary into src/myPyllant/const.py</p> Source code in <code>myPyllant/tests/find_countries.py</code> <pre><code>def main():\n    print(\"COUNTRIES = {\")\n    for brand in BRANDS.keys():\n        if brand not in COUNTRIES.keys():\n            # Some brands have no country-specific realms\n            continue\n        print(f'    \"{brand}\": {{')\n        for country_name, country in countries_with_realm(brand):\n            print(f'        \"{country_name}\": \"{country}\",')\n        print(\"    },\")\n    print(\"}\")\n</code></pre>"},{"location":"3-contributing/#adding-new-api-endpoints","title":"Adding new API endpoints","text":"<p>If your myVAILLANT app has more features than this integration, chances are you have a more complex system then me. You can reverse engineer the API endpoints and open an issue with the requests + responses. See Reverse Engineering for a tutorial.</p>"},{"location":"3-contributing/#running-commands-on-your-home-assistant-installation-in-docker","title":"Running commands on your Home Assistant installation in Docker","text":"<p>If you're using this component in a Home Assistant installation that uses docker compose, you can run these commands directly (from the folder that contains your <code>docker-compose.yml</code>):</p> <pre><code>docker compose exec homeassistant python3 -m myPyllant.tests.generate_test_data username password brand --country country\n# Note the output folder\ndocker compose cp homeassistant:&lt;testdata folder&gt; .\n# Test data will be copied to your current directory\n</code></pre>"},{"location":"3-contributing/#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Auth is loosely based on ioBroker.vaillant</li> <li>Most API endpoints are reverse-engineered from the myVaillant app, using mitmproxy</li> <li>Logo based on Hase Icons erstellt von Freepik - Flaticon &amp; Ouroboros Icons erstellt von Freepik - Flaticon.</li> </ul>"},{"location":"3-library/","title":"CLI &amp; Python Library","text":""},{"location":"3-library/#cli-python-library","title":"CLI &amp; Python Library","text":"<p>The myPyllant library can interact with the API behind the myVAILLANT app  (and branded versions of it, such as the MiGo app from Saunier Duval). Needs at least Python 3.10.</p> <p>Not affiliated with Vaillant, the developers take no responsibility for anything that happens to your devices because of this library.</p>"},{"location":"3-library/#installation","title":"Installation","text":"<p>Warning</p> <p>You need at least Python 3.10</p> <pre><code>pip install myPyllant\npython3 -m myPyllant.export user password brand --country country\n# See python3 -m myPyllant.export -h for more options and a list of countries\n</code></pre> <p>..or use Docker:</p> <pre><code>docker run -ti ghcr.io/signalkraft/mypyllant:latest python3 -m myPyllant.export user password brand --country country\n</code></pre> <p>The <code>--data</code> argument exports historical data of the devices in your system. Without this keyword, information about your system will be exported as JSON.</p>"},{"location":"3-library/#usage","title":"Usage","text":""},{"location":"3-library/#exporting-data-about-your-system","title":"Exporting Data about your System","text":"<pre><code>python3 -m myPyllant.export user password brand --country country\n# See python3 -m myPyllant.export -h for more options and a list of countries\n</code></pre> <p>The <code>--data</code> argument exports historical data of the devices in your system. Without this keyword, information about your system will be exported as JSON.</p> Source code in <code>myPyllant/export.py</code> <pre><code>async def main(\n    user,\n    password,\n    brand,\n    country=None,\n    data=False,\n    resolution=None,\n    start=None,\n    end=None,\n):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        export_list = []\n        async for system in api.get_systems(\n            include_connection_status=True,\n            include_diagnostic_trouble_codes=True,\n            include_rts=True,\n            include_mpc=True,\n            include_ambisense_rooms=True,\n            include_energy_management=True,\n            include_eebus=True,\n        ):\n            if data:\n                for device in system.devices:\n                    data = [\n                        prepare_data(d)\n                        async for d in api.get_data_by_device(\n                            device, resolution, start, end\n                        )\n                    ]\n                    device_dict = device.prepare_dict()\n                    # Data in the device doesn't contain any actual data,\n                    # only information on what kind of data is available\n                    del device_dict[\"data\"]\n                    export_list.append(dict(device=device_dict, data=data))\n            else:\n                export_list.append(system.prepare_dict())\n\n        return export_list\n</code></pre>"},{"location":"3-library/#exporting-energy-reports","title":"Exporting Energy Reports","text":"<pre><code>python3 -m myPyllant.report user password brand --country country\n# Wrote 2023 report to energy_data_2023_ArothermPlus_XYZ.csv\n# Wrote 2023 report to energy_data_2023_HydraulicStation_XYZ.csv\n</code></pre> <p>Writes a report for each heat generator, by default for the current year. You can provide <code>--year</code> to select a different year.</p> Source code in <code>myPyllant/report.py</code> <pre><code>async def main(user, password, brand, year: int, country=None, write_results=True):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        results = []\n        async for system in api.get_systems():\n            reports = api.get_yearly_reports(system, year)\n            async for report in reports:\n                if write_results:\n                    with open(report.file_name, \"w\") as fh:\n                        fh.write(report.file_content)\n                    sys.stdout.write(f\"Wrote {year} report to {report.file_name}\\n\")\n                else:\n                    results.append(report)\n        if not write_results:\n            return results\n</code></pre>"},{"location":"3-library/#using-the-api-in-python","title":"Using the API in Python","text":"<pre><code>#!/usr/bin/env python3\n\nimport argparse\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\n\nfrom myPyllant.api import MyPyllantAPI\nfrom myPyllant.const import ALL_COUNTRIES, BRANDS, DEFAULT_BRAND\n\nparser = argparse.ArgumentParser(description=\"Export data from myVaillant API   .\")\nparser.add_argument(\"user\", help=\"Username (email address) for the myVaillant app\")\nparser.add_argument(\"password\", help=\"Password for the myVaillant app\")\nparser.add_argument(\n    \"brand\",\n    help=\"Brand your account is registered in, i.e. 'vaillant'\",\n    default=DEFAULT_BRAND,\n    choices=BRANDS.keys(),\n)\nparser.add_argument(\n    \"--country\",\n    help=\"Country your account is registered in, i.e. 'germany'\",\n    choices=ALL_COUNTRIES.keys(),\n    required=False,\n)\nparser.add_argument(\n    \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n)\n\n\nasync def main(user, password, brand, country):\n    async with MyPyllantAPI(user, password, brand, country) as api:\n        async for system in api.get_systems():\n            print(await api.set_set_back_temperature(system.zones[0], 18))\n            print(await api.quick_veto_zone_temperature(system.zones[0], 21, 5))\n            print(await api.cancel_quick_veto_zone_temperature(system.zones[0]))\n            setpoint = 10.0 if system.control_identifier.is_vrc700 else None\n            print(\n                await api.set_holiday(\n                    system,\n                    datetime.now(system.timezone),\n                    datetime.now(system.timezone) + timedelta(days=7),\n                    setpoint,  # Setpoint is only required for VRC700 systems\n                )\n            )\n            print(await api.cancel_holiday(system))\n            if system.domestic_hot_water:\n                print(await api.boost_domestic_hot_water(system.domestic_hot_water[0]))\n                print(await api.cancel_hot_water_boost(system.domestic_hot_water[0]))\n                print(\n                    await api.set_domestic_hot_water_temperature(\n                        system.domestic_hot_water[0], 46\n                    )\n                )\n\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main(args.user, args.password, args.brand, args.country))\n</code></pre> <p>Want to contribute more features? Checkout out the contribution section.</p>"},{"location":"3-library/#api-documentation","title":"API Documentation","text":"Source code in <code>myPyllant/api.py</code> <pre><code>class MyPyllantAPI:\n    username: str\n    password: str\n    aiohttp_session: CountingClientSession\n    oauth_session: dict = {}\n    oauth_session_expires: datetime.datetime | None = None\n    control_identifiers: dict[str, str] = {}\n    time_zones: dict[str, str] = {}\n\n    def __init__(\n        self, username: str, password: str, brand: str, country: str | None = None\n    ) -&gt; None:\n        if brand not in BRANDS.keys():\n            raise ValueError(\n                f\"Invalid brand, must be one of {', '.join(BRANDS.keys())}\"\n            )\n        if brand in COUNTRIES:\n            # Only need to valid country, if the brand exists as a key in COUNTRIES\n            if not country:\n                raise RealmInvalid(f\"{BRANDS[brand]} requires country to be passed\")\n            elif country not in COUNTRIES[brand].keys():\n                raise RealmInvalid(\n                    f\"Invalid country, {BRANDS[brand]} only supports {', '.join(COUNTRIES[brand].keys())}\"\n                )\n\n        self.username = username\n        self.password = password\n        self.country = country\n        self.brand = brand\n\n        self.aiohttp_session = get_http_client()\n\n    async def __aenter__(self) -&gt; MyPyllantAPI:\n        try:\n            await self.login()\n        except Exception:\n            await self.aiohttp_session.close()\n            raise\n        return self\n\n    async def __aexit__(self, *args, **kwargs) -&gt; None:\n        if not self.aiohttp_session.closed:\n            await self.aiohttp_session.close()\n\n    async def login(self):\n        code, code_verifier = await self.get_code()\n        self.oauth_session = await self.get_token(code, code_verifier)\n        logger.debug(\"Got session %s\", self.oauth_session)\n        self.set_session_expires()\n\n    async def get_code(self):\n        \"\"\"\n        This should really be done in the browser with OIDC, but that's not easy without support from Vaillant\n\n        So instead, we grab the login endpoint from the HTML form of the login website and send username + password\n        to obtain a session\n        \"\"\"\n\n        code_verifier, code_challenge = generate_code()\n        auth_querystring = {\n            \"response_type\": \"code\",\n            \"client_id\": CLIENT_ID,\n            \"code\": \"code_challenge\",\n            \"redirect_uri\": \"enduservaillant.page.link://login\",\n            \"code_challenge_method\": \"S256\",\n            \"code_challenge\": code_challenge,\n        }\n\n        # Grabbing the login URL from the HTML form of the login page\n        code = None\n        try:\n            async with self.aiohttp_session.get(\n                AUTHENTICATE_URL.format(realm=get_realm(self.brand, self.country))\n                + \"?\"\n                + urlencode(auth_querystring),\n                allow_redirects=False,\n            ) as resp:\n                login_html = await resp.text()\n                if \"Location\" in resp.headers:\n                    parsed_url = urlparse(resp.headers[\"Location\"])\n                    code = parse_qs(parsed_url.query).get(\"code\")\n        except ClientResponseError as e:\n            raise LoginEndpointInvalid from e\n\n        if not code:\n            result = re.search(\n                LOGIN_URL.format(realm=get_realm(self.brand, self.country))\n                + r\"\\?([^\\\"]*)\",\n                login_html,\n            )\n            login_url = unescape(result.group()) if result else None\n            if not login_url:\n                raise AuthenticationFailed(\"Could not get login URL\")\n\n            logger.debug(\"Got login url %s\", login_url)\n            login_payload = {\n                \"username\": self.username,\n                \"password\": self.password,\n                \"credentialId\": \"\",\n            }\n            # Obtaining the code\n            async with self.aiohttp_session.post(\n                login_url, data=login_payload, allow_redirects=False\n            ) as resp:\n                logger.debug(\"Got login response headers %s\", resp.headers)\n                if \"Location\" not in resp.headers:\n                    raise AuthenticationFailed(\"Login failed\")\n                logger.debug(\n                    f\"Got location from authorize endpoint: {resp.headers['Location']}\"\n                )\n                parsed_url = urlparse(resp.headers[\"Location\"])\n                code = parse_qs(parsed_url.query)[\"code\"]\n        return code, code_verifier\n\n    async def get_token(self, code, code_verifier):\n        # Obtaining access token and refresh token\n        token_payload = {\n            \"grant_type\": \"authorization_code\",\n            \"client_id\": \"myvaillant\",\n            \"code\": code,\n            \"code_verifier\": code_verifier,\n            \"redirect_uri\": \"enduservaillant.page.link://login\",\n        }\n\n        async with self.aiohttp_session.post(\n            TOKEN_URL.format(realm=get_realm(self.brand, self.country)),\n            data=token_payload,\n            raise_for_status=False,\n        ) as resp:\n            login_json = await resp.json()\n            if resp.status &gt;= 400:\n                logger.error(\n                    f\"Could not log in, got status {resp.status} this response: {login_json}\"\n                )\n                raise Exception(login_json)\n            return login_json\n\n    def set_session_expires(self):\n        self.oauth_session_expires = datetime.datetime.now(\n            datetime.timezone.utc\n        ) + datetime.timedelta(seconds=self.oauth_session[\"expires_in\"])\n        logger.debug(\"Session expires in %s\", self.oauth_session_expires)\n\n    async def refresh_token(self):\n        refresh_payload = {\n            \"refresh_token\": self.oauth_session[\"refresh_token\"],\n            \"client_id\": CLIENT_ID,\n            \"grant_type\": \"refresh_token\",\n        }\n        async with self.aiohttp_session.post(\n            TOKEN_URL.format(realm=get_realm(self.brand, self.country)),\n            data=refresh_payload,\n        ) as resp:\n            self.oauth_session = await resp.json()\n            self.set_session_expires()\n            return self.oauth_session\n\n    @property\n    def access_token(self):\n        return self.oauth_session[\"access_token\"]\n\n    def get_authorized_headers(self):\n        return {\n            \"Authorization\": \"Bearer \" + self.access_token,\n            \"x-app-identifier\": \"VAILLANT\",\n            \"Accept-Language\": \"en-GB\",\n            \"Accept\": \"application/json, text/plain, */*\",\n            \"x-client-locale\": \"en-GB\",\n            \"x-idm-identifier\": \"KEYCLOAK\",\n            \"ocp-apim-subscription-key\": \"1e0a2f3511fb4c5bbb1c7f9fedd20b1c\",\n            \"User-Agent\": \"okhttp/4.9.2\",\n            \"Connection\": \"keep-alive\",\n        }\n\n    async def get_api_base(\n        self,\n        system: str | System | None = None,\n        control_identifier: ControlIdentifier | str | None = None,\n    ) -&gt; str:\n        if system and not control_identifier:\n            control_identifier = await self.get_control_identifier(system)\n        return get_api_base(control_identifier)\n\n    async def get_system_api_base(\n        self,\n        system: str | System,\n        control_identifier: ControlIdentifier | str | None = None,\n    ) -&gt; str:\n        if not control_identifier:\n            control_identifier = await self.get_control_identifier(system)\n        return get_system_api_base(system, control_identifier)\n\n    async def get_homes(self) -&gt; AsyncIterator[Home]:\n        \"\"\"\n        Returns configured homes and their system IDs\n\n        Returns:\n            An Async Iterator with all the configured `Home` objects for the logged-in user\n        \"\"\"\n        async with self.aiohttp_session.get(\n            f\"{await self.get_api_base()}/homes\", headers=self.get_authorized_headers()\n        ) as homes_resp:\n            for home_json in dict_to_snake_case(await homes_resp.json()):\n                if \"system_id\" not in home_json or not home_json[\"system_id\"]:\n                    logger.warning(\n                        \"Skipping home because system_id is missing or empty: %s\",\n                        home_json,\n                    )\n                    continue\n                timezone = await self.get_time_zone(home_json[\"system_id\"])\n                yield Home.from_api(timezone=timezone, **home_json)\n\n    async def get_systems(\n        self,\n        include_connection_status: bool = False,\n        include_diagnostic_trouble_codes: bool = False,\n        include_rts: bool = False,\n        include_mpc: bool = False,\n        include_ambisense_rooms: bool = False,\n        include_energy_management: bool = False,\n        include_eebus: bool = False,\n        include_ambisense_capability: bool = False,\n        homes: list[Home] | None = None,\n    ) -&gt; AsyncIterator[System]:\n        \"\"\"\n        Returns an async generator of systems under control of the user\n\n        Parameters:\n            include_connection_status: Fetches connection status for each system\n            include_diagnostic_trouble_codes: Fetches diagnostic trouble codes for each system and device\n            include_rts: Fetches RTS data for each system, only supported on TLI controllers\n            include_mpc: Fetches MPC data for each system, only supported on TLI controllers\n            include_ambisense_rooms: Fetches Ambisense room data\n            include_energy_management: Fetches energy management data\n            include_eebus: Fetches eebus information\n            include_ambisense_capability: Fetches eebus information\n            homes: Use this list of Home objects instead of fetching them\n\n        Returns:\n            An Async Iterator with all the `System` objects\n\n        Examples:\n            &gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n            &gt;&gt;&gt;    print(system.water_pressure)\n        \"\"\"\n        if not homes:\n            homes = [home async for home in self.get_homes()]\n        for home in homes:\n            control_identifier = await self.get_control_identifier(home.system_id)\n            system_url = await self.get_system_api_base(home.system_id)\n            current_system_url = (\n                f\"{await self.get_api_base()}/emf/v2/{home.system_id}/currentSystem\"\n            )\n\n            async with self.aiohttp_session.get(\n                system_url, headers=self.get_authorized_headers()\n            ) as system_resp:\n                system_raw = await system_resp.text()\n                if control_identifier.is_vrc700:\n                    system_raw = system_raw.replace(\"domesticHotWater\", \"dhw\")\n                    system_raw = system_raw.replace(\"DomesticHotWater\", \"Dhw\")\n                system_json = dict_to_snake_case(json.loads(system_raw))\n\n            async with self.aiohttp_session.get(\n                current_system_url, headers=self.get_authorized_headers()\n            ) as current_system_resp:\n                current_system_json = await current_system_resp.json()\n\n            system = System.from_api(\n                brand=self.brand,\n                home=home,\n                timezone=home.timezone,\n                control_identifier=control_identifier,\n                connected=await self.get_connection_status(home.system_id)\n                if include_connection_status\n                else None,\n                diagnostic_trouble_codes=await self.get_diagnostic_trouble_codes(\n                    home.system_id\n                )\n                if include_diagnostic_trouble_codes\n                else None,\n                rts=await self.get_rts(home.system_id) if include_rts else None,\n                mpc=await self.get_mpc(home.system_id) if include_mpc else None,\n                current_system=dict_to_snake_case(current_system_json),\n                ambisense_capability=await self.get_ambisense_capability(home.system_id)\n                if include_ambisense_capability\n                else False,\n                ambisense_rooms=await self.get_ambisense_rooms(home.system_id)\n                if include_ambisense_rooms\n                else [],\n                energy_management=await self.get_energy_management(home.system_id)\n                if include_energy_management\n                else None,\n                eebus=await self.get_eebus(home.system_id) if include_eebus else None,\n                **dict_to_snake_case(system_json),\n            )\n            yield system\n\n    async def get_data_by_device(\n        self,\n        device: Device,\n        data_resolution: DeviceDataBucketResolution = DeviceDataBucketResolution.DAY,\n        data_from: datetime.datetime | None = None,\n        data_to: datetime.datetime | None = None,\n    ) -&gt; AsyncIterator[DeviceData]:\n        \"\"\"\n        Gets all energy data for a device\n\n        Parameters:\n            device: The device\n            data_resolution: Which resolution level (i.e. day, month)\n            data_from: Starting datetime\n            data_to: End datetime\n\n        \"\"\"\n\n        # ISO formatted dates in querystring require timezone information\n        if data_from and not data_from.tzinfo:\n            data_from = data_from.replace(tzinfo=device.timezone)\n        if data_to and not data_to.tzinfo:\n            data_to = data_to.replace(tzinfo=device.timezone)\n\n        apis_hit = 0\n\n        for data in device.data:\n            if data.skip_data_update:\n                logger.debug(\n                    \"Skipping data update for %s on %s\",\n                    data.operation_mode,\n                    device.name_display,\n                )\n                yield data\n                continue\n            data_from = data_from or data.data_from\n            if not data_from:\n                raise ValueError(\n                    \"No data_from set, and no data_from found in device data\"\n                )\n            data_to = data_to or data.data_to\n            if not data_to:\n                raise ValueError(\"No data_to set, and no data_to found in device data\")\n            querystring = {\n                \"resolution\": str(data_resolution),\n                \"operationMode\": data.operation_mode,\n                \"energyType\": data.value_type,\n                \"startDate\": data_from.isoformat(timespec=\"milliseconds\"),\n                \"endDate\": data_to.isoformat(timespec=\"milliseconds\"),\n            }\n            device_buckets_url = (\n                f\"{await self.get_api_base()}/emf/v2/{device.system_id}/\"\n                f\"devices/{device.device_uuid}/buckets?{urlencode(querystring)}\"\n            )\n            async with self.aiohttp_session.get(\n                device_buckets_url, headers=self.get_authorized_headers()\n            ) as device_buckets_resp:\n                device_buckets_json = await device_buckets_resp.json()\n                yield DeviceData.from_api(\n                    timezone=device.timezone,\n                    device=device,\n                    **dict_to_snake_case(device_buckets_json),\n                )\n                apis_hit += 1\n        logger.debug(f\"Queried {apis_hit} API endpoints for device data\")\n\n    async def get_yearly_reports(\n        self,\n        system: System,\n        year: int | None = None,\n    ) -&gt; AsyncIterator[SystemReport]:\n        \"\"\"\n        Returns an async generator of systems under control of the user\n\n        Parameters:\n            system: The System object or system ID string\n            year: The year of the report\n        \"\"\"\n        url = f\"{await self.get_api_base()}/emf/v2/{system.id}/report/{year}\"\n        async with self.aiohttp_session.get(\n            url, headers=self.get_authorized_headers()\n        ) as report_resp:\n            reports_json = await report_resp.json()\n            for report in dict_to_snake_case(reports_json):\n                yield SystemReport.from_api(**report)\n\n    async def set_zone_operating_mode(\n        self,\n        zone: Zone,\n        mode: ZoneOperatingMode | ZoneOperatingModeVRC700 | str,\n        operating_type: str = \"heating\",\n    ):\n        \"\"\"\n        Sets the operating mode for a zone\n\n        Parameters:\n            zone: The target zone\n            mode: The target operating mode\n            operating_type: Either heating or cooling\n        \"\"\"\n        payload = {}\n        operating_type = operating_type.lower()\n        if operating_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid HVAC mode, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        if zone.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{operating_type}/operation-mode\"\n            mode_enum = ZoneOperatingModeVRC700  # type: ignore\n        else:\n            if operating_type == \"cooling\":\n                url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/operation-mode\"\n                payload[\"type\"] = operating_type.upper()\n            else:\n                url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/{operating_type}-operation-mode\"\n            mode_enum = ZoneOperatingMode  # type: ignore\n\n        if mode not in mode_enum:\n            raise ValueError(\n                f\"Invalid mode, must be one of {', '.join(mode_enum.__members__)}\"\n            )\n\n        payload[\"operationMode\"] = str(mode)\n\n        await self.aiohttp_session.patch(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n\n        # zone.heating.operation_mode_heating or zone.cooling.operation_mode_cooling\n        setattr(\n            getattr(zone, operating_type),\n            f\"operation_mode_{operating_type}\",\n            mode_enum(mode),\n        )\n        return zone\n\n    async def quick_veto_zone_temperature(\n        self,\n        zone: Zone,\n        temperature: float,\n        duration_hours: float | None = None,\n        default_duration: float | None = None,\n        veto_type: str = \"heating\",\n    ):\n        \"\"\"\n        Temporarily overwrites the desired temperature in a zone\n\n        Parameters:\n            zone: The target zone\n            temperature: The target temperature\n            duration_hours: Optional, sets overwrite for this many hours\n            default_duration: Optional, falls back to this default duration if duration_hours is not given\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if not default_duration:\n            default_duration = DEFAULT_QUICK_VETO_DURATION\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZoneOperatingType:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        if zone.current_special_function == ZoneCurrentSpecialFunction.QUICK_VETO:\n            logger.debug(\n                f\"Patching quick veto for {zone.name} because it is already in quick veto mode\"\n            )\n            payload = {\n                \"desiredRoomTemperatureSetpoint\": temperature,\n            }\n            if duration_hours:\n                payload[\"duration\"] = duration_hours\n            await self.aiohttp_session.patch(\n                url,\n                json=payload,\n                headers=self.get_authorized_headers(),\n            )\n            zone.desired_room_temperature_setpoint = temperature\n            return zone\n        else:\n            await self.aiohttp_session.post(\n                url,\n                json={\n                    \"desiredRoomTemperatureSetpoint\": temperature,\n                    \"duration\": duration_hours if duration_hours else default_duration,\n                },\n                headers=self.get_authorized_headers(),\n            )\n            zone.desired_room_temperature_setpoint = temperature\n            zone.quick_veto_start_date_time = datetime.datetime.now(zone.timezone)\n            zone.quick_veto_end_date_time = datetime.datetime.now(\n                zone.timezone\n            ) + datetime.timedelta(hours=(duration_hours or default_duration))\n            return zone\n\n    async def quick_veto_zone_duration(\n        self,\n        zone: Zone,\n        duration_hours: float,\n        veto_type: str = \"heating\",\n    ):\n        \"\"\"\n        Updates the quick veto duration\n\n        Parameters:\n            zone: The target zone\n            duration_hours: Updates quick veto duration (in hours)\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZoneOperatingType:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        await self.aiohttp_session.patch(\n            url,\n            json={\"duration\": duration_hours},\n            headers=self.get_authorized_headers(),\n        )\n        zone.quick_veto_end_date_time = datetime.datetime.now(\n            zone.timezone\n        ) + datetime.timedelta(hours=duration_hours)\n        return zone\n\n    async def set_time_program_temperature(\n        self,\n        zone: Zone,\n        program_type: str,\n        temperature: float,\n        update_similar_to_dow: str | None = None,\n    ):\n        logger.debug(f\"Setting time program temp {zone.name}\")\n\n        if program_type not in ZoneOperatingType:\n            raise ValueError(\n                \"Type must be either heating or cooling, not %s\", program_type\n            )\n\n        if not zone.heating.time_program_heating:\n            raise ValueError(\n                \"There is no time program set, temperature can't be updated\",\n                program_type,\n            )\n\n        time_program = zone.heating.time_program_heating\n        time_program.set_setpoint(temperature, update_similar_to_dow)\n        return await self.set_zone_time_program(zone, program_type, time_program)\n\n    async def set_manual_mode_setpoint(\n        self,\n        zone: Zone,\n        temperature: float,\n        setpoint_type: str | ZoneOperatingType = \"heating\",\n    ):\n        \"\"\"\n        Sets the desired temperature when in manual mode\n\n        Parameters:\n            zone: The target zone\n            temperature: The target temperature\n            setpoint_type: Either heating or cooling\n        \"\"\"\n        logger.debug(\"Setting manual mode setpoint for %s\", zone.name)\n        if setpoint_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        setpoint_type = str(setpoint_type).lower()\n        payload: dict[str, Any] = {\n            \"setpoint\": temperature,\n        }\n        if zone.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setpoint_type}/manual-mode-setpoint\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/manual-mode-setpoint\"\n            payload[\"type\"] = setpoint_type.upper()\n        await self.aiohttp_session.patch(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n        # zone.heating.manual_mode_setpoint_heating or zone.cooling.manual_mode_setpoint_cooling\n        setattr(\n            getattr(zone, setpoint_type.lower()),\n            f\"manual_mode_setpoint_{setpoint_type}\",\n            temperature,\n        )\n\n        if (\n            setpoint_type == \"cooling\"\n            and zone.cooling\n            and zone.cooling.operation_mode_cooling == ZoneOperatingMode.MANUAL\n        ):\n            zone.desired_room_temperature_setpoint_cooling = temperature\n\n        return zone\n\n    async def set_time_controlled_cooling_setpoint(\n        self,\n        zone: Zone,\n        temperature: float,\n    ):\n        logger.debug(\"Setting time controlled setpoint for cooling on %s\", zone.name)\n        if zone.control_identifier.is_vrc700:\n            raise ValueError(\n                \"Time controlled cooling setpoint is not supported on VRC700 controllers\"\n            )\n\n        payload: dict[str, Any] = {\n            \"setpoint\": temperature,\n        }\n        await self.aiohttp_session.patch(\n            f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/setpoint-cooling\",\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n        if zone.cooling:\n            if zone.cooling.operation_mode_cooling == ZoneOperatingMode.TIME_CONTROLLED:\n                zone.desired_room_temperature_setpoint_cooling = temperature\n            zone.cooling.setpoint_cooling = temperature\n        return zone\n\n    async def cancel_quick_veto_zone_temperature(\n        self, zone: Zone, veto_type: str = \"heating\"\n    ):\n        \"\"\"\n        Cancels a previously set quick veto in a zone\n\n        Parameters:\n            zone: The target zone\n            veto_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if veto_type not in ZoneOperatingType:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n        await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n        zone.quick_veto_start_date_time = None\n        zone.quick_veto_end_date_time = None\n        zone.current_special_function = ZoneCurrentSpecialFunction.NONE\n        return zone\n\n    async def set_set_back_temperature(\n        self, zone: Zone, temperature: float, setback_type: str = \"heating\"\n    ):\n        \"\"\"\n        Sets the temperature that a zone gets lowered to in away mode\n\n        Parameters:\n            zone: The target zone\n            temperature: The setback temperature\n            setback_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if zone.control_identifier.is_vrc700:\n            if setback_type not in ZoneOperatingType:\n                raise ValueError(\n                    f\"Invalid setback type, must be one of {', '.join(ZoneOperatingType)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/set-back-temperature\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/set-back-temperature\"\n        await self.aiohttp_session.patch(\n            url,\n            json={\"setBackTemperature\": temperature},\n            headers=self.get_authorized_headers(),\n        )\n        # TODO: What to do with cooling?\n        if setback_type == \"heating\":\n            zone.heating.set_back_temperature = temperature\n        return zone\n\n    async def set_zone_time_program(\n        self,\n        zone: Zone,\n        program_type: str,\n        time_program: ZoneTimeProgram,\n        setback_type: str = \"heating\",\n    ):\n        \"\"\"\n        Sets the temperature that a zone gets lowered to in away mode\n\n        Parameters:\n            zone: The target zone\n            program_type: Which program to set\n            time_program: The time schedule\n            setback_type: Only supported on VRC700 controllers, either heating or cooling\n        \"\"\"\n        if program_type not in ZoneOperatingType:\n            raise ValueError(\n                \"Type must be either heating or cooling, not %s\", program_type\n            )\n        if zone.control_identifier.is_vrc700:\n            if setback_type not in ZoneOperatingType:\n                raise ValueError(\n                    f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n                )\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/time-windows\"\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/time-windows\"\n        data = asdict(time_program)\n        data[\"type\"] = program_type\n        del data[\"meta_info\"]\n        await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n\n        # zone.heating.time_program_heating = time_program or zone.cooling.time_program_cooling = time_program\n        setattr(\n            getattr(zone, setback_type), f\"time_program_{setback_type}\", time_program\n        )\n        return zone\n\n    async def set_holiday(\n        self,\n        system: System,\n        start: datetime.datetime | None = None,\n        end: datetime.datetime | None = None,\n        setpoint: float | None = None,\n    ):\n        \"\"\"\n        Sets away mode / holiday mode on a system\n\n        Parameters:\n            system: The target system\n            start: Optional, datetime when the system goes into away mode. Defaults to now\n            end: Optional, datetime when away mode should end. Defaults to one year from now\n            setpoint: Optional, setpoint temperature during holiday, only supported on VRC700 controllers\n        \"\"\"\n        start, end = get_default_holiday_dates(start, end, system.timezone)\n        logger.debug(\n            \"Setting holiday mode for system %s to %s - %s\", system.id, start, end\n        )\n        if not start &lt;= end:\n            raise ValueError(\"Start of holiday mode must be before end\")\n\n        data = {\n            \"startDateTime\": datetime_format(start, with_microseconds=True),\n            \"endDateTime\": datetime_format(end, with_microseconds=True),\n        }\n\n        if system.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n            if setpoint is None:\n                raise ValueError(\"setpoint is required on this controller\")\n            data[\"setpoint\"] = setpoint  # type: ignore\n        else:\n            url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n            if setpoint is not None:\n                raise ValueError(\"setpoint is not supported on this controller\")\n\n        await self.aiohttp_session.post(\n            url, json=data, headers=self.get_authorized_headers()\n        )\n        for zone in system.zones:\n            zone.current_special_function = ZoneCurrentSpecialFunction.HOLIDAY\n            zone.general.holiday_start_date_time = start\n            zone.general.holiday_end_date_time = end\n        return system\n\n    async def cancel_holiday(self, system: System):\n        \"\"\"\n        Cancels a previously set away mode / holiday mode on a system\n\n        Parameters:\n            system: The target system\n        \"\"\"\n        if system.control_identifier.is_vrc700:\n            url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n        else:\n            url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n\n        await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n        for zone in system.zones:\n            zone.current_special_function = ZoneCurrentSpecialFunction.NONE\n            zone.general.holiday_start_date_time = None\n            zone.general.holiday_end_date_time = None\n        return system\n\n    async def set_cooling_for_days(\n        self,\n        system: System,\n        start: datetime.datetime | None = None,\n        end: datetime.datetime | None = None,\n        duration_days: int | None = None,\n    ):\n        \"\"\"\n        Sets cooling for a number of days\n\n        Parameters:\n            system: The target system\n            start: Optional, datetime when the system goes into cooling mode. Defaults to now\n            end: Optional, datetime when cooling mode should end. Defaults to one year from now\n            duration_days: Optional, number of days to cool\n        \"\"\"\n        data: dict[str, int | str] = {}\n        if system.control_identifier.is_vrc700:\n            if not duration_days:\n                raise ValueError(\"duration_days is required on VRC700 controllers\")\n            if start or end:\n                raise ValueError(\n                    \"Start and end dates are not supported on VRC700 controllers, use duration_days instead\"\n                )\n            data[\"value\"] = duration_days\n        else:\n            if duration_days:\n                if start or end:\n                    raise ValueError(\n                        \"Start and end dates can't be used together with duration_days\"\n                    )\n                start = datetime.datetime.now(system.timezone)\n                end = start + datetime.timedelta(days=duration_days)\n            else:\n                start, end = get_default_holiday_dates(start, end, system.timezone)\n            if not start &lt;= end:\n                raise ValueError(\"Start of holiday mode must be before end\")\n            data[\"startDateTime\"] = datetime_format(start, with_microseconds=True)\n            data[\"endDateTime\"] = datetime_format(end, with_microseconds=True)\n\n        logger.debug(\n            \"Setting cooling for days on system %s with data %s\", system.id, data\n        )\n\n        await self.aiohttp_session.post(\n            f\"{await self.get_system_api_base(system.id)}/cooling-for-days\",\n            json=data,\n            headers=self.get_authorized_headers(),\n        )\n\n        if start and end:\n            system.configuration[\"system\"][\"manual_cooling_start_date\"] = (\n                datetime_format(start)\n            )\n            system.configuration[\"system\"][\"manual_cooling_end_date\"] = datetime_format(\n                end\n            )\n        if system.control_identifier.is_vrc700:\n            system.configuration[\"system\"][\"cooling_for_x_days\"] = duration_days\n        return system\n\n    async def cancel_cooling_for_days(self, system: System):\n        await self.aiohttp_session.delete(\n            f\"{await self.get_system_api_base(system.id)}/cooling-for-days\",\n            headers=self.get_authorized_headers(),\n        )\n        system.configuration[\"system\"][\"manual_cooling_start_date\"] = None\n        system.configuration[\"system\"][\"manual_cooling_end_date\"] = None\n        return system\n\n    async def set_ventilation_boost(\n        self,\n        system: System,\n    ):\n        if system.control_identifier.is_vrc700:\n            raise ValueError(\"Not supported on VRC700 controllers\")\n\n        await self.aiohttp_session.post(\n            f\"{await self.get_system_api_base(system.id)}/ventilation-boost\",\n            json={},\n            headers=self.get_authorized_headers(),\n        )\n\n        for zone in system.zones:\n            zone.current_special_function = ZoneCurrentSpecialFunction.VENTILATION_BOOST\n        return system\n\n    async def cancel_ventilation_boost(self, system: System):\n        if system.control_identifier.is_vrc700:\n            raise ValueError(\"Not supported on VRC700 controllers\")\n\n        await self.aiohttp_session.delete(\n            f\"{await self.get_system_api_base(system.id)}/ventilation-boost\",\n            headers=self.get_authorized_headers(),\n        )\n\n        # TODO: Need the switch to the right previous special function\n        for zone in system.zones:\n            zone.current_special_function = ZoneCurrentSpecialFunction.NONE\n        return system\n\n    async def set_domestic_hot_water_temperature(\n        self, domestic_hot_water: DomesticHotWater, temperature: int | float\n    ):\n        \"\"\"\n        Sets the desired hot water temperature\n\n        Parameters:\n            domestic_hot_water: The water heater\n            temperature: The desired temperature, only whole numbers are supported by the API, floats get rounded\n        \"\"\"\n        if isinstance(temperature, float):\n            logger.warning(\"Domestic hot water can only be set to whole numbers\")\n            temperature = int(round(temperature, 0))\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/temperature\"\n        )\n        await self.aiohttp_session.patch(\n            url, json={\"setpoint\": temperature}, headers=self.get_authorized_headers()\n        )\n        domestic_hot_water.tapping_setpoint = temperature\n        return domestic_hot_water\n\n    async def boost_domestic_hot_water(self, domestic_hot_water: DomesticHotWater):\n        \"\"\"\n        Temporarily boosts hot water temperature\n\n        Parameters:\n            domestic_hot_water: The water heater\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n        )\n        await self.aiohttp_session.post(\n            url, json={}, headers=self.get_authorized_headers()\n        )\n        domestic_hot_water.current_special_function = (\n            DHWCurrentSpecialFunction.CYLINDER_BOOST\n        )\n        return domestic_hot_water\n\n    async def cancel_hot_water_boost(self, domestic_hot_water: DomesticHotWater):\n        \"\"\"\n        Cancels hot water boost\n\n        Parameters:\n            domestic_hot_water: The water heater\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n        )\n        await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n        domestic_hot_water.current_special_function = DHWCurrentSpecialFunction.REGULAR\n        return domestic_hot_water\n\n    async def set_domestic_hot_water_operation_mode(\n        self,\n        domestic_hot_water: DomesticHotWater,\n        mode: DHWOperationMode | DHWOperationModeVRC700 | str,\n    ):\n        \"\"\"\n        Sets the operation mode for water heating\n\n        Parameters:\n            domestic_hot_water: The water heater\n            mode: The operation mode\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}/domestic-hot-water/\"\n            f\"{domestic_hot_water.index}/operation-mode\"\n        )\n        await self.aiohttp_session.patch(\n            url,\n            json={\"operationMode\": str(mode)},\n            headers=self.get_authorized_headers(),\n        )\n\n        if isinstance(mode, str):\n            if domestic_hot_water.control_identifier.is_vrc700:\n                mode = DHWOperationModeVRC700(mode)\n            else:\n                mode = DHWOperationMode(mode)\n        domestic_hot_water.operation_mode_dhw = mode\n        return domestic_hot_water\n\n    async def set_domestic_hot_water_time_program(\n        self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n    ):\n        \"\"\"\n        Sets the schedule for heating water\n\n        Parameters:\n            domestic_hot_water: The water heater\n            time_program: The schedule\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/time-windows\"\n        )\n        data = asdict(time_program)\n        del data[\"meta_info\"]\n        await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n        domestic_hot_water.time_program_dhw = time_program\n        return domestic_hot_water\n\n    async def set_domestic_hot_water_circulation_time_program(\n        self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n    ):\n        \"\"\"\n        Sets the schedule for the water circulation pump\n\n        Parameters:\n            domestic_hot_water: The water heater\n            time_program: The schedule\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n            f\"/domestic-hot-water/{domestic_hot_water.index}/circulation-pump-time-windows\"\n        )\n        data = asdict(time_program)\n        del data[\"meta_info\"]\n        await self.aiohttp_session.patch(\n            url,\n            json=dict_to_camel_case(data),\n            headers=self.get_authorized_headers(),\n        )\n        domestic_hot_water.time_program_circulation_pump = time_program\n        return domestic_hot_water\n\n    async def set_ventilation_operation_mode(\n        self,\n        ventilation: Ventilation,\n        mode: VentilationOperationMode | VentilationOperationModeVRC700,\n    ):\n        \"\"\"\n        Sets the operation mode for a ventilation device\n\n        Parameters:\n            ventilation: The ventilation device\n            mode: The operation mode\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(ventilation.system_id)}\"\n            f\"/ventilation/{ventilation.index}/operation-mode\"\n        )\n        await self.aiohttp_session.patch(\n            url,\n            json={\n                \"operationMode\": str(mode),\n            },\n            headers=self.get_authorized_headers(),\n        )\n        ventilation.operation_mode_ventilation = mode\n        return ventilation\n\n    async def set_ventilation_fan_stage(\n        self,\n        ventilation: Ventilation,\n        maximum_fan_stage: int,\n        fan_stage_type: VentilationFanStageType,\n    ):\n        \"\"\"\n        Sets the maximum fan stage for a stage type\n\n        Parameters:\n            ventilation: The ventilation device\n            maximum_fan_stage: The maximum fan speed, from 1-6\n            fan_stage_type: The fan stage type (day or night)\n        \"\"\"\n        url = (\n            f\"{await self.get_system_api_base(ventilation.system_id)}\"\n            f\"/ventilation/{ventilation.index}/fan-stage\"\n        )\n        await self.aiohttp_session.patch(\n            url,\n            json={\n                \"maximumFanStage\": maximum_fan_stage,\n                \"type\": str(fan_stage_type),\n            },\n            headers=self.get_authorized_headers(),\n        )\n        setattr(\n            ventilation,\n            f\"maximum_{fan_stage_type.lower()}_fan_stage\",\n            maximum_fan_stage,\n        )\n        return ventilation\n\n    async def get_connection_status(self, system: System | str) -&gt; bool:\n        \"\"\"\n        Returns whether the system is online\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/meta-info/connection-status\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            return (await response.json())[\"connected\"]\n        except KeyError:\n            logger.warning(\"Couldn't get connection status\")\n            return False\n\n    async def get_control_identifier(self, system: System | str) -&gt; ControlIdentifier:\n        \"\"\"\n        The control identifier is used in the URL to request system information (usually `tli`)\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        system_id = get_system_id(system)\n\n        if system_id in self.control_identifiers:\n            # We already have the control identifier cached\n            control_identifier = self.control_identifiers[system_id]\n        else:\n            url = (\n                f\"{await self.get_api_base()}/systems/\"\n                f\"{system_id}/meta-info/control-identifier\"\n            )\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n            try:\n                control_identifier = (await response.json())[\"controlIdentifier\"]\n                self.control_identifiers[system_id] = control_identifier\n            except KeyError:\n                logger.warning(\"Couldn't get control identifier\")\n                control_identifier = DEFAULT_CONTROL_IDENTIFIER\n\n        return ControlIdentifier(control_identifier)\n\n    async def get_time_zone(self, system: System | str) -&gt; datetime.tzinfo | None:\n        \"\"\"\n        Gets the configured timezone for a system\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        system_id = get_system_id(system)\n        if system_id in self.time_zones:\n            # We already have the tz cached\n            logger.debug(\"Using cached timezone for system %s\", system_id)\n            return ZoneInfo(key=self.time_zones[system_id])\n        else:\n            logger.debug(\"Fetching timezone for system %s\", system_id)\n            url = (\n                f\"{await self.get_api_base()}/systems/\"\n                f\"{get_system_id(system)}/meta-info/time-zone\"\n            )\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n            try:\n                tz_key = (await response.json())[\"timeZone\"]\n                self.time_zones[system_id] = tz_key\n                return ZoneInfo(key=tz_key)\n            except (KeyError, TypeError):\n                logger.warning(\"Couldn't get timezone from API\")\n                return None\n\n    async def get_diagnostic_trouble_codes(\n        self, system: System | str\n    ) -&gt; list[dict] | None:\n        \"\"\"\n        Returns a list of trouble codes by device\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/diagnostic-trouble-codes\"\n        )\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get diagnostic trouble codes\", exc_info=e)\n            return None\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_rts(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets RTS data, which contains on/off cycles and operation time\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base()}/rts/{get_system_id(system)}/devices\"\n        try:\n            logger.debug(\"Getting RTS data\")\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get RTS data\", exc_info=e)\n            return {\"statistics\": []}\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_mpc(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets live power usage data per device\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base()}/hem/{get_system_id(system)}/mpc\"\n        try:\n            logger.debug(\"Getting MPC data\")\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get MPC data\", exc_info=e)\n            return {\"devices\": []}\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_energy_management(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets energy management information\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base()}/eebus/energy-management/{get_system_id(system)}\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get energy management data\", exc_info=e)\n            return {}\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def get_eebus(self, system: System | str) -&gt; dict:\n        \"\"\"\n        Gets EEBUS information\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{await self.get_api_base()}/ship/{get_system_id(system)}/self\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get eebus information\", exc_info=e)\n            return {}\n        result = await response.json()\n        return dict_to_snake_case(result)\n\n    async def toggle_eebus(\n        self, system: System | str, enabled: bool = True\n    ) -&gt; System | None:\n        \"\"\"\n        Enables EEBUS interface\n\n        Parameters:\n            system: The System object or system ID string\n            enabled: Whether to enable or disable EEBUS\n        \"\"\"\n        await self.aiohttp_session.put(\n            f\"{await self.get_api_base()}/ship/{get_system_id(system)}/self/spine\",\n            json={\"enabled\": enabled},\n            headers=self.get_authorized_headers(),\n        )\n        if isinstance(system, System) and system.eebus:\n            system.eebus[\"spline_enabled\"] = enabled\n            return system\n        return None\n\n    async def get_ambisense_capability(self, system: System | str) -&gt; bool:\n        \"\"\"\n        Whether a system is ambisense capable\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{get_api_base()}/api/v1/ambisense/facilities/{get_system_id(system)}/capability\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get ambisense capability data\", exc_info=e)\n            return False\n        result = await response.json()\n        return dict_to_snake_case(result).get(\"rbr_capable\", False)\n\n    async def get_ambisense_rooms(self, system: System | str) -&gt; list[dict]:\n        \"\"\"\n        Whether a system is ambisense capable\n\n        Parameters:\n            system: The System object or system ID string\n        \"\"\"\n        url = f\"{get_api_base()}/api/v1/ambisense/facilities/{get_system_id(system)}/rooms\"\n        try:\n            response = await self.aiohttp_session.get(\n                url,\n                headers=self.get_authorized_headers(),\n            )\n        except ClientResponseError as e:\n            logger.warning(\"Could not get rooms data\", exc_info=e)\n            return []\n        result = dict_to_snake_case(await response.json())\n        for room in result:\n            room[\"time_program\"] = room.pop(\"timeprogram\")\n        return result\n\n    async def set_ambisense_room_operation_mode(\n        self,\n        room: AmbisenseRoom,\n        mode: AmbisenseRoomOperationMode | str,\n    ) -&gt; AmbisenseRoom:\n        \"\"\"\n        Sets the operation mode for a room\n\n        Parameters:\n            room: The room\n            mode: The operation mode\n        \"\"\"\n        url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/operation-mode\"\n        await self.aiohttp_session.put(\n            url,\n            json={\"operationMode\": str(mode).lower()},\n            headers=self.get_authorized_headers(),\n        )\n\n        if isinstance(mode, str):\n            room.room_configuration.operation_mode = AmbisenseRoomOperationMode(\n                mode.upper()\n            )\n        else:\n            room.room_configuration.operation_mode = mode\n        return room\n\n    async def quick_veto_ambisense_room(\n        self,\n        room: AmbisenseRoom,\n        temperature: float,\n        duration_minutes: int | None = None,\n        default_duration: int | None = None,\n    ) -&gt; AmbisenseRoom:\n        \"\"\"\n        Temporarily overwrites the desired temperature in a room\n\n        Parameters:\n            room: The target room\n            temperature: The target temperature\n            duration_minutes: Optional, sets overwrite for this many minutes\n            default_duration: Optional, falls back to this default duration if duration_minutes is not given\n        \"\"\"\n        if not default_duration:\n            default_duration = (\n                int(DEFAULT_QUICK_VETO_DURATION) * 60\n            )  # duration for quick veto for room is in minutes\n\n        if duration_minutes and duration_minutes &lt; 30:\n            raise ValueError(\"duration_minutes must be greater than 30\")\n\n        url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/quick-veto\"\n\n        payload = {\n            \"temperatureSetpoint\": temperature,\n            \"duration\": duration_minutes or default_duration,\n        }\n\n        await self.aiohttp_session.put(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n\n        room.room_configuration.temperature_setpoint = temperature\n        room.room_configuration.quick_veto_end_time = datetime.datetime.now(\n            datetime.timezone.utc\n        ) + datetime.timedelta(minutes=(duration_minutes or default_duration))\n        return room\n\n    async def cancel_quick_veto_ambisense_room(\n        self, room: AmbisenseRoom\n    ) -&gt; AmbisenseRoom:\n        \"\"\"\n        Cancels a previously set quick veto in a room\n\n        Parameters:\n            room: The target room\n        \"\"\"\n        url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/quick-veto\"\n\n        await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n        room.room_configuration.quick_veto_end_time = None\n        return room\n\n    async def set_ambisense_room_manual_mode_setpoint_temperature(\n        self,\n        room: AmbisenseRoom,\n        temperature: float,\n    ):\n        \"\"\"\n        Sets the desired temperature when in manual mode. The temperature is only taken into account if the room is in\n        MANUAL mode, otherwise it has no effect.\n\n        Parameters:\n            room: The target room\n            temperature: The target temperature\n        \"\"\"\n        logger.debug(\n            \"Setting manual mode setpoint temperature to %.1f for %s\",\n            temperature,\n            room.name,\n        )\n        payload: dict[str, Any] = {\n            \"temperatureSetpoint\": temperature,\n        }\n        url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/temperature-setpoint\"\n\n        await self.aiohttp_session.put(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n        room.room_configuration.temperature_setpoint = temperature\n        return room\n\n    async def set_ambisense_room_time_program(\n        self, room: AmbisenseRoom, time_program: RoomTimeProgram\n    ) -&gt; AmbisenseRoom:\n        \"\"\"\n        Set time program for an ambisense room\n\n        Parameters:\n            room: The target room\n            time_program: The new time program\n        \"\"\"\n        url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/timeprogram\"\n\n        data = asdict(time_program, dict_factory=RoomTimeProgram.dict_factory)\n        payload = dict_to_camel_case(data)\n\n        await self.aiohttp_session.put(\n            url, json=payload, headers=self.get_authorized_headers()\n        )\n        room.time_program = time_program\n        return room\n\n    async def set_circuit_heating_curve(\n        self,\n        circuit: Circuit,\n        heating_curve: float,\n    ) -&gt; Circuit:\n        \"\"\"\n        Set heating curve value for a circuit\n\n        :param circuit:\n        :param heating_curve:\n        :return:\n        \"\"\"\n        url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/heating-curve\"\n\n        await self.aiohttp_session.patch(\n            url,\n            json={\"heatingCurve\": heating_curve},\n            headers=self.get_authorized_headers(),\n        )\n        circuit.heating_curve = heating_curve\n        return circuit\n\n    async def set_circuit_heat_demand_limited_by_outside_temperature(\n        self,\n        circuit: Circuit,\n        heat_demand_limited_by_outside_temperature: float,\n    ) -&gt; Circuit:\n        \"\"\"\n        Set heating curve value for a circuit\n\n        :param circuit:\n        :param heat_demand_limited_by_outside_temperature:\n        :return:\n        \"\"\"\n        url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/heat-demand-limited-by-outside-temperature\"\n\n        await self.aiohttp_session.post(\n            url,\n            json={\n                \"heatDemandLimitedByOutsideTemperature\": heat_demand_limited_by_outside_temperature\n            },\n            headers=self.get_authorized_headers(),\n        )\n        circuit.heat_demand_limited_by_outside_temperature = (\n            heat_demand_limited_by_outside_temperature\n        )\n        return circuit\n\n    async def set_circuit_min_flow_temperature_setpoint(\n        self,\n        circuit: Circuit,\n        min_flow_temperature_setpoint: float,\n    ) -&gt; Circuit:\n        \"\"\"\n        Set heating curve value for a circuit\n\n        :param circuit:\n        :param min_flow_temperature_setpoint:\n        :return:\n        \"\"\"\n        url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/min-flow-temperature-setpoint\"\n\n        await self.aiohttp_session.patch(\n            url,\n            json={\"minFlowTemperatureSetpoint\": min_flow_temperature_setpoint},\n            headers=self.get_authorized_headers(),\n        )\n        circuit.heating_flow_temperature_minimum_setpoint = (\n            min_flow_temperature_setpoint\n        )\n        return circuit\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.boost_domestic_hot_water","title":"<code>boost_domestic_hot_water(domestic_hot_water)</code>  <code>async</code>","text":"<p>Temporarily boosts hot water temperature</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def boost_domestic_hot_water(self, domestic_hot_water: DomesticHotWater):\n    \"\"\"\n    Temporarily boosts hot water temperature\n\n    Parameters:\n        domestic_hot_water: The water heater\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n    )\n    await self.aiohttp_session.post(\n        url, json={}, headers=self.get_authorized_headers()\n    )\n    domestic_hot_water.current_special_function = (\n        DHWCurrentSpecialFunction.CYLINDER_BOOST\n    )\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.cancel_holiday","title":"<code>cancel_holiday(system)</code>  <code>async</code>","text":"<p>Cancels a previously set away mode / holiday mode on a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The target system</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_holiday(self, system: System):\n    \"\"\"\n    Cancels a previously set away mode / holiday mode on a system\n\n    Parameters:\n        system: The target system\n    \"\"\"\n    if system.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n    else:\n        url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n\n    await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n    for zone in system.zones:\n        zone.current_special_function = ZoneCurrentSpecialFunction.NONE\n        zone.general.holiday_start_date_time = None\n        zone.general.holiday_end_date_time = None\n    return system\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.cancel_hot_water_boost","title":"<code>cancel_hot_water_boost(domestic_hot_water)</code>  <code>async</code>","text":"<p>Cancels hot water boost</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_hot_water_boost(self, domestic_hot_water: DomesticHotWater):\n    \"\"\"\n    Cancels hot water boost\n\n    Parameters:\n        domestic_hot_water: The water heater\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/boost\"\n    )\n    await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n    domestic_hot_water.current_special_function = DHWCurrentSpecialFunction.REGULAR\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.cancel_quick_veto_ambisense_room","title":"<code>cancel_quick_veto_ambisense_room(room)</code>  <code>async</code>","text":"<p>Cancels a previously set quick veto in a room</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>AmbisenseRoom</code> <p>The target room</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_quick_veto_ambisense_room(\n    self, room: AmbisenseRoom\n) -&gt; AmbisenseRoom:\n    \"\"\"\n    Cancels a previously set quick veto in a room\n\n    Parameters:\n        room: The target room\n    \"\"\"\n    url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/quick-veto\"\n\n    await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n    room.room_configuration.quick_veto_end_time = None\n    return room\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.cancel_quick_veto_zone_temperature","title":"<code>cancel_quick_veto_zone_temperature(zone, veto_type='heating')</code>  <code>async</code>","text":"<p>Cancels a previously set quick veto in a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def cancel_quick_veto_zone_temperature(\n    self, zone: Zone, veto_type: str = \"heating\"\n):\n    \"\"\"\n    Cancels a previously set quick veto in a zone\n\n    Parameters:\n        zone: The target zone\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    await self.aiohttp_session.delete(url, headers=self.get_authorized_headers())\n    zone.quick_veto_start_date_time = None\n    zone.quick_veto_end_date_time = None\n    zone.current_special_function = ZoneCurrentSpecialFunction.NONE\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_ambisense_capability","title":"<code>get_ambisense_capability(system)</code>  <code>async</code>","text":"<p>Whether a system is ambisense capable</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_ambisense_capability(self, system: System | str) -&gt; bool:\n    \"\"\"\n    Whether a system is ambisense capable\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{get_api_base()}/api/v1/ambisense/facilities/{get_system_id(system)}/capability\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get ambisense capability data\", exc_info=e)\n        return False\n    result = await response.json()\n    return dict_to_snake_case(result).get(\"rbr_capable\", False)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_ambisense_rooms","title":"<code>get_ambisense_rooms(system)</code>  <code>async</code>","text":"<p>Whether a system is ambisense capable</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_ambisense_rooms(self, system: System | str) -&gt; list[dict]:\n    \"\"\"\n    Whether a system is ambisense capable\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{get_api_base()}/api/v1/ambisense/facilities/{get_system_id(system)}/rooms\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get rooms data\", exc_info=e)\n        return []\n    result = dict_to_snake_case(await response.json())\n    for room in result:\n        room[\"time_program\"] = room.pop(\"timeprogram\")\n    return result\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_code","title":"<code>get_code()</code>  <code>async</code>","text":"<p>This should really be done in the browser with OIDC, but that's not easy without support from Vaillant</p> <p>So instead, we grab the login endpoint from the HTML form of the login website and send username + password to obtain a session</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_code(self):\n    \"\"\"\n    This should really be done in the browser with OIDC, but that's not easy without support from Vaillant\n\n    So instead, we grab the login endpoint from the HTML form of the login website and send username + password\n    to obtain a session\n    \"\"\"\n\n    code_verifier, code_challenge = generate_code()\n    auth_querystring = {\n        \"response_type\": \"code\",\n        \"client_id\": CLIENT_ID,\n        \"code\": \"code_challenge\",\n        \"redirect_uri\": \"enduservaillant.page.link://login\",\n        \"code_challenge_method\": \"S256\",\n        \"code_challenge\": code_challenge,\n    }\n\n    # Grabbing the login URL from the HTML form of the login page\n    code = None\n    try:\n        async with self.aiohttp_session.get(\n            AUTHENTICATE_URL.format(realm=get_realm(self.brand, self.country))\n            + \"?\"\n            + urlencode(auth_querystring),\n            allow_redirects=False,\n        ) as resp:\n            login_html = await resp.text()\n            if \"Location\" in resp.headers:\n                parsed_url = urlparse(resp.headers[\"Location\"])\n                code = parse_qs(parsed_url.query).get(\"code\")\n    except ClientResponseError as e:\n        raise LoginEndpointInvalid from e\n\n    if not code:\n        result = re.search(\n            LOGIN_URL.format(realm=get_realm(self.brand, self.country))\n            + r\"\\?([^\\\"]*)\",\n            login_html,\n        )\n        login_url = unescape(result.group()) if result else None\n        if not login_url:\n            raise AuthenticationFailed(\"Could not get login URL\")\n\n        logger.debug(\"Got login url %s\", login_url)\n        login_payload = {\n            \"username\": self.username,\n            \"password\": self.password,\n            \"credentialId\": \"\",\n        }\n        # Obtaining the code\n        async with self.aiohttp_session.post(\n            login_url, data=login_payload, allow_redirects=False\n        ) as resp:\n            logger.debug(\"Got login response headers %s\", resp.headers)\n            if \"Location\" not in resp.headers:\n                raise AuthenticationFailed(\"Login failed\")\n            logger.debug(\n                f\"Got location from authorize endpoint: {resp.headers['Location']}\"\n            )\n            parsed_url = urlparse(resp.headers[\"Location\"])\n            code = parse_qs(parsed_url.query)[\"code\"]\n    return code, code_verifier\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_connection_status","title":"<code>get_connection_status(system)</code>  <code>async</code>","text":"<p>Returns whether the system is online</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_connection_status(self, system: System | str) -&gt; bool:\n    \"\"\"\n    Returns whether the system is online\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = (\n        f\"{await self.get_api_base()}/systems/\"\n        f\"{get_system_id(system)}/meta-info/connection-status\"\n    )\n    response = await self.aiohttp_session.get(\n        url,\n        headers=self.get_authorized_headers(),\n    )\n    try:\n        return (await response.json())[\"connected\"]\n    except KeyError:\n        logger.warning(\"Couldn't get connection status\")\n        return False\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_control_identifier","title":"<code>get_control_identifier(system)</code>  <code>async</code>","text":"<p>The control identifier is used in the URL to request system information (usually <code>tli</code>)</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_control_identifier(self, system: System | str) -&gt; ControlIdentifier:\n    \"\"\"\n    The control identifier is used in the URL to request system information (usually `tli`)\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    system_id = get_system_id(system)\n\n    if system_id in self.control_identifiers:\n        # We already have the control identifier cached\n        control_identifier = self.control_identifiers[system_id]\n    else:\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{system_id}/meta-info/control-identifier\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            control_identifier = (await response.json())[\"controlIdentifier\"]\n            self.control_identifiers[system_id] = control_identifier\n        except KeyError:\n            logger.warning(\"Couldn't get control identifier\")\n            control_identifier = DEFAULT_CONTROL_IDENTIFIER\n\n    return ControlIdentifier(control_identifier)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_data_by_device","title":"<code>get_data_by_device(device, data_resolution=DeviceDataBucketResolution.DAY, data_from=None, data_to=None)</code>  <code>async</code>","text":"<p>Gets all energy data for a device</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Device</code> <p>The device</p> required <code>data_resolution</code> <code>DeviceDataBucketResolution</code> <p>Which resolution level (i.e. day, month)</p> <code>DAY</code> <code>data_from</code> <code>datetime | None</code> <p>Starting datetime</p> <code>None</code> <code>data_to</code> <code>datetime | None</code> <p>End datetime</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_data_by_device(\n    self,\n    device: Device,\n    data_resolution: DeviceDataBucketResolution = DeviceDataBucketResolution.DAY,\n    data_from: datetime.datetime | None = None,\n    data_to: datetime.datetime | None = None,\n) -&gt; AsyncIterator[DeviceData]:\n    \"\"\"\n    Gets all energy data for a device\n\n    Parameters:\n        device: The device\n        data_resolution: Which resolution level (i.e. day, month)\n        data_from: Starting datetime\n        data_to: End datetime\n\n    \"\"\"\n\n    # ISO formatted dates in querystring require timezone information\n    if data_from and not data_from.tzinfo:\n        data_from = data_from.replace(tzinfo=device.timezone)\n    if data_to and not data_to.tzinfo:\n        data_to = data_to.replace(tzinfo=device.timezone)\n\n    apis_hit = 0\n\n    for data in device.data:\n        if data.skip_data_update:\n            logger.debug(\n                \"Skipping data update for %s on %s\",\n                data.operation_mode,\n                device.name_display,\n            )\n            yield data\n            continue\n        data_from = data_from or data.data_from\n        if not data_from:\n            raise ValueError(\n                \"No data_from set, and no data_from found in device data\"\n            )\n        data_to = data_to or data.data_to\n        if not data_to:\n            raise ValueError(\"No data_to set, and no data_to found in device data\")\n        querystring = {\n            \"resolution\": str(data_resolution),\n            \"operationMode\": data.operation_mode,\n            \"energyType\": data.value_type,\n            \"startDate\": data_from.isoformat(timespec=\"milliseconds\"),\n            \"endDate\": data_to.isoformat(timespec=\"milliseconds\"),\n        }\n        device_buckets_url = (\n            f\"{await self.get_api_base()}/emf/v2/{device.system_id}/\"\n            f\"devices/{device.device_uuid}/buckets?{urlencode(querystring)}\"\n        )\n        async with self.aiohttp_session.get(\n            device_buckets_url, headers=self.get_authorized_headers()\n        ) as device_buckets_resp:\n            device_buckets_json = await device_buckets_resp.json()\n            yield DeviceData.from_api(\n                timezone=device.timezone,\n                device=device,\n                **dict_to_snake_case(device_buckets_json),\n            )\n            apis_hit += 1\n    logger.debug(f\"Queried {apis_hit} API endpoints for device data\")\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_diagnostic_trouble_codes","title":"<code>get_diagnostic_trouble_codes(system)</code>  <code>async</code>","text":"<p>Returns a list of trouble codes by device</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_diagnostic_trouble_codes(\n    self, system: System | str\n) -&gt; list[dict] | None:\n    \"\"\"\n    Returns a list of trouble codes by device\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = (\n        f\"{await self.get_api_base()}/systems/\"\n        f\"{get_system_id(system)}/diagnostic-trouble-codes\"\n    )\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get diagnostic trouble codes\", exc_info=e)\n        return None\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_eebus","title":"<code>get_eebus(system)</code>  <code>async</code>","text":"<p>Gets EEBUS information</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_eebus(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets EEBUS information\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base()}/ship/{get_system_id(system)}/self\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get eebus information\", exc_info=e)\n        return {}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_energy_management","title":"<code>get_energy_management(system)</code>  <code>async</code>","text":"<p>Gets energy management information</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_energy_management(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets energy management information\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base()}/eebus/energy-management/{get_system_id(system)}\"\n    try:\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get energy management data\", exc_info=e)\n        return {}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_homes","title":"<code>get_homes()</code>  <code>async</code>","text":"<p>Returns configured homes and their system IDs</p> <p>Returns:</p> Type Description <code>AsyncIterator[Home]</code> <p>An Async Iterator with all the configured <code>Home</code> objects for the logged-in user</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_homes(self) -&gt; AsyncIterator[Home]:\n    \"\"\"\n    Returns configured homes and their system IDs\n\n    Returns:\n        An Async Iterator with all the configured `Home` objects for the logged-in user\n    \"\"\"\n    async with self.aiohttp_session.get(\n        f\"{await self.get_api_base()}/homes\", headers=self.get_authorized_headers()\n    ) as homes_resp:\n        for home_json in dict_to_snake_case(await homes_resp.json()):\n            if \"system_id\" not in home_json or not home_json[\"system_id\"]:\n                logger.warning(\n                    \"Skipping home because system_id is missing or empty: %s\",\n                    home_json,\n                )\n                continue\n            timezone = await self.get_time_zone(home_json[\"system_id\"])\n            yield Home.from_api(timezone=timezone, **home_json)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_mpc","title":"<code>get_mpc(system)</code>  <code>async</code>","text":"<p>Gets live power usage data per device</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_mpc(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets live power usage data per device\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base()}/hem/{get_system_id(system)}/mpc\"\n    try:\n        logger.debug(\"Getting MPC data\")\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get MPC data\", exc_info=e)\n        return {\"devices\": []}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_rts","title":"<code>get_rts(system)</code>  <code>async</code>","text":"<p>Gets RTS data, which contains on/off cycles and operation time</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_rts(self, system: System | str) -&gt; dict:\n    \"\"\"\n    Gets RTS data, which contains on/off cycles and operation time\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    url = f\"{await self.get_api_base()}/rts/{get_system_id(system)}/devices\"\n    try:\n        logger.debug(\"Getting RTS data\")\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n    except ClientResponseError as e:\n        logger.warning(\"Could not get RTS data\", exc_info=e)\n        return {\"statistics\": []}\n    result = await response.json()\n    return dict_to_snake_case(result)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_systems","title":"<code>get_systems(include_connection_status=False, include_diagnostic_trouble_codes=False, include_rts=False, include_mpc=False, include_ambisense_rooms=False, include_energy_management=False, include_eebus=False, include_ambisense_capability=False, homes=None)</code>  <code>async</code>","text":"<p>Returns an async generator of systems under control of the user</p> <p>Parameters:</p> Name Type Description Default <code>include_connection_status</code> <code>bool</code> <p>Fetches connection status for each system</p> <code>False</code> <code>include_diagnostic_trouble_codes</code> <code>bool</code> <p>Fetches diagnostic trouble codes for each system and device</p> <code>False</code> <code>include_rts</code> <code>bool</code> <p>Fetches RTS data for each system, only supported on TLI controllers</p> <code>False</code> <code>include_mpc</code> <code>bool</code> <p>Fetches MPC data for each system, only supported on TLI controllers</p> <code>False</code> <code>include_ambisense_rooms</code> <code>bool</code> <p>Fetches Ambisense room data</p> <code>False</code> <code>include_energy_management</code> <code>bool</code> <p>Fetches energy management data</p> <code>False</code> <code>include_eebus</code> <code>bool</code> <p>Fetches eebus information</p> <code>False</code> <code>include_ambisense_capability</code> <code>bool</code> <p>Fetches eebus information</p> <code>False</code> <code>homes</code> <code>list[Home] | None</code> <p>Use this list of Home objects instead of fetching them</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[System]</code> <p>An Async Iterator with all the <code>System</code> objects</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n&gt;&gt;&gt;    print(system.water_pressure)\n</code></pre> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_systems(\n    self,\n    include_connection_status: bool = False,\n    include_diagnostic_trouble_codes: bool = False,\n    include_rts: bool = False,\n    include_mpc: bool = False,\n    include_ambisense_rooms: bool = False,\n    include_energy_management: bool = False,\n    include_eebus: bool = False,\n    include_ambisense_capability: bool = False,\n    homes: list[Home] | None = None,\n) -&gt; AsyncIterator[System]:\n    \"\"\"\n    Returns an async generator of systems under control of the user\n\n    Parameters:\n        include_connection_status: Fetches connection status for each system\n        include_diagnostic_trouble_codes: Fetches diagnostic trouble codes for each system and device\n        include_rts: Fetches RTS data for each system, only supported on TLI controllers\n        include_mpc: Fetches MPC data for each system, only supported on TLI controllers\n        include_ambisense_rooms: Fetches Ambisense room data\n        include_energy_management: Fetches energy management data\n        include_eebus: Fetches eebus information\n        include_ambisense_capability: Fetches eebus information\n        homes: Use this list of Home objects instead of fetching them\n\n    Returns:\n        An Async Iterator with all the `System` objects\n\n    Examples:\n        &gt;&gt;&gt; async for system in MyPyllantAPI(**kwargs).get_systems():\n        &gt;&gt;&gt;    print(system.water_pressure)\n    \"\"\"\n    if not homes:\n        homes = [home async for home in self.get_homes()]\n    for home in homes:\n        control_identifier = await self.get_control_identifier(home.system_id)\n        system_url = await self.get_system_api_base(home.system_id)\n        current_system_url = (\n            f\"{await self.get_api_base()}/emf/v2/{home.system_id}/currentSystem\"\n        )\n\n        async with self.aiohttp_session.get(\n            system_url, headers=self.get_authorized_headers()\n        ) as system_resp:\n            system_raw = await system_resp.text()\n            if control_identifier.is_vrc700:\n                system_raw = system_raw.replace(\"domesticHotWater\", \"dhw\")\n                system_raw = system_raw.replace(\"DomesticHotWater\", \"Dhw\")\n            system_json = dict_to_snake_case(json.loads(system_raw))\n\n        async with self.aiohttp_session.get(\n            current_system_url, headers=self.get_authorized_headers()\n        ) as current_system_resp:\n            current_system_json = await current_system_resp.json()\n\n        system = System.from_api(\n            brand=self.brand,\n            home=home,\n            timezone=home.timezone,\n            control_identifier=control_identifier,\n            connected=await self.get_connection_status(home.system_id)\n            if include_connection_status\n            else None,\n            diagnostic_trouble_codes=await self.get_diagnostic_trouble_codes(\n                home.system_id\n            )\n            if include_diagnostic_trouble_codes\n            else None,\n            rts=await self.get_rts(home.system_id) if include_rts else None,\n            mpc=await self.get_mpc(home.system_id) if include_mpc else None,\n            current_system=dict_to_snake_case(current_system_json),\n            ambisense_capability=await self.get_ambisense_capability(home.system_id)\n            if include_ambisense_capability\n            else False,\n            ambisense_rooms=await self.get_ambisense_rooms(home.system_id)\n            if include_ambisense_rooms\n            else [],\n            energy_management=await self.get_energy_management(home.system_id)\n            if include_energy_management\n            else None,\n            eebus=await self.get_eebus(home.system_id) if include_eebus else None,\n            **dict_to_snake_case(system_json),\n        )\n        yield system\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_time_zone","title":"<code>get_time_zone(system)</code>  <code>async</code>","text":"<p>Gets the configured timezone for a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def get_time_zone(self, system: System | str) -&gt; datetime.tzinfo | None:\n    \"\"\"\n    Gets the configured timezone for a system\n\n    Parameters:\n        system: The System object or system ID string\n    \"\"\"\n    system_id = get_system_id(system)\n    if system_id in self.time_zones:\n        # We already have the tz cached\n        logger.debug(\"Using cached timezone for system %s\", system_id)\n        return ZoneInfo(key=self.time_zones[system_id])\n    else:\n        logger.debug(\"Fetching timezone for system %s\", system_id)\n        url = (\n            f\"{await self.get_api_base()}/systems/\"\n            f\"{get_system_id(system)}/meta-info/time-zone\"\n        )\n        response = await self.aiohttp_session.get(\n            url,\n            headers=self.get_authorized_headers(),\n        )\n        try:\n            tz_key = (await response.json())[\"timeZone\"]\n            self.time_zones[system_id] = tz_key\n            return ZoneInfo(key=tz_key)\n        except (KeyError, TypeError):\n            logger.warning(\"Couldn't get timezone from API\")\n            return None\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.get_yearly_reports","title":"<code>get_yearly_reports(system, year=None)</code>  <code>async</code>","text":"<p>Returns an async generator of systems under control of the user</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The System object or system ID string</p> required <code>year</code> <code>int | None</code> <p>The year of the report</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def get_yearly_reports(\n    self,\n    system: System,\n    year: int | None = None,\n) -&gt; AsyncIterator[SystemReport]:\n    \"\"\"\n    Returns an async generator of systems under control of the user\n\n    Parameters:\n        system: The System object or system ID string\n        year: The year of the report\n    \"\"\"\n    url = f\"{await self.get_api_base()}/emf/v2/{system.id}/report/{year}\"\n    async with self.aiohttp_session.get(\n        url, headers=self.get_authorized_headers()\n    ) as report_resp:\n        reports_json = await report_resp.json()\n        for report in dict_to_snake_case(reports_json):\n            yield SystemReport.from_api(**report)\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.quick_veto_ambisense_room","title":"<code>quick_veto_ambisense_room(room, temperature, duration_minutes=None, default_duration=None)</code>  <code>async</code>","text":"<p>Temporarily overwrites the desired temperature in a room</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>AmbisenseRoom</code> <p>The target room</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required <code>duration_minutes</code> <code>int | None</code> <p>Optional, sets overwrite for this many minutes</p> <code>None</code> <code>default_duration</code> <code>int | None</code> <p>Optional, falls back to this default duration if duration_minutes is not given</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def quick_veto_ambisense_room(\n    self,\n    room: AmbisenseRoom,\n    temperature: float,\n    duration_minutes: int | None = None,\n    default_duration: int | None = None,\n) -&gt; AmbisenseRoom:\n    \"\"\"\n    Temporarily overwrites the desired temperature in a room\n\n    Parameters:\n        room: The target room\n        temperature: The target temperature\n        duration_minutes: Optional, sets overwrite for this many minutes\n        default_duration: Optional, falls back to this default duration if duration_minutes is not given\n    \"\"\"\n    if not default_duration:\n        default_duration = (\n            int(DEFAULT_QUICK_VETO_DURATION) * 60\n        )  # duration for quick veto for room is in minutes\n\n    if duration_minutes and duration_minutes &lt; 30:\n        raise ValueError(\"duration_minutes must be greater than 30\")\n\n    url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/quick-veto\"\n\n    payload = {\n        \"temperatureSetpoint\": temperature,\n        \"duration\": duration_minutes or default_duration,\n    }\n\n    await self.aiohttp_session.put(\n        url,\n        json=payload,\n        headers=self.get_authorized_headers(),\n    )\n\n    room.room_configuration.temperature_setpoint = temperature\n    room.room_configuration.quick_veto_end_time = datetime.datetime.now(\n        datetime.timezone.utc\n    ) + datetime.timedelta(minutes=(duration_minutes or default_duration))\n    return room\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.quick_veto_zone_duration","title":"<code>quick_veto_zone_duration(zone, duration_hours, veto_type='heating')</code>  <code>async</code>","text":"<p>Updates the quick veto duration</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>duration_hours</code> <code>float</code> <p>Updates quick veto duration (in hours)</p> required <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def quick_veto_zone_duration(\n    self,\n    zone: Zone,\n    duration_hours: float,\n    veto_type: str = \"heating\",\n):\n    \"\"\"\n    Updates the quick veto duration\n\n    Parameters:\n        zone: The target zone\n        duration_hours: Updates quick veto duration (in hours)\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    await self.aiohttp_session.patch(\n        url,\n        json={\"duration\": duration_hours},\n        headers=self.get_authorized_headers(),\n    )\n    zone.quick_veto_end_date_time = datetime.datetime.now(\n        zone.timezone\n    ) + datetime.timedelta(hours=duration_hours)\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.quick_veto_zone_temperature","title":"<code>quick_veto_zone_temperature(zone, temperature, duration_hours=None, default_duration=None, veto_type='heating')</code>  <code>async</code>","text":"<p>Temporarily overwrites the desired temperature in a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required <code>duration_hours</code> <code>float | None</code> <p>Optional, sets overwrite for this many hours</p> <code>None</code> <code>default_duration</code> <code>float | None</code> <p>Optional, falls back to this default duration if duration_hours is not given</p> <code>None</code> <code>veto_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def quick_veto_zone_temperature(\n    self,\n    zone: Zone,\n    temperature: float,\n    duration_hours: float | None = None,\n    default_duration: float | None = None,\n    veto_type: str = \"heating\",\n):\n    \"\"\"\n    Temporarily overwrites the desired temperature in a zone\n\n    Parameters:\n        zone: The target zone\n        temperature: The target temperature\n        duration_hours: Optional, sets overwrite for this many hours\n        default_duration: Optional, falls back to this default duration if duration_hours is not given\n        veto_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if not default_duration:\n        default_duration = DEFAULT_QUICK_VETO_DURATION\n    if zone.control_identifier.is_vrc700:\n        if veto_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{veto_type}/quick-veto\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/quick-veto\"\n\n    if zone.current_special_function == ZoneCurrentSpecialFunction.QUICK_VETO:\n        logger.debug(\n            f\"Patching quick veto for {zone.name} because it is already in quick veto mode\"\n        )\n        payload = {\n            \"desiredRoomTemperatureSetpoint\": temperature,\n        }\n        if duration_hours:\n            payload[\"duration\"] = duration_hours\n        await self.aiohttp_session.patch(\n            url,\n            json=payload,\n            headers=self.get_authorized_headers(),\n        )\n        zone.desired_room_temperature_setpoint = temperature\n        return zone\n    else:\n        await self.aiohttp_session.post(\n            url,\n            json={\n                \"desiredRoomTemperatureSetpoint\": temperature,\n                \"duration\": duration_hours if duration_hours else default_duration,\n            },\n            headers=self.get_authorized_headers(),\n        )\n        zone.desired_room_temperature_setpoint = temperature\n        zone.quick_veto_start_date_time = datetime.datetime.now(zone.timezone)\n        zone.quick_veto_end_date_time = datetime.datetime.now(\n            zone.timezone\n        ) + datetime.timedelta(hours=(duration_hours or default_duration))\n        return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_ambisense_room_manual_mode_setpoint_temperature","title":"<code>set_ambisense_room_manual_mode_setpoint_temperature(room, temperature)</code>  <code>async</code>","text":"<p>Sets the desired temperature when in manual mode. The temperature is only taken into account if the room is in MANUAL mode, otherwise it has no effect.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>AmbisenseRoom</code> <p>The target room</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ambisense_room_manual_mode_setpoint_temperature(\n    self,\n    room: AmbisenseRoom,\n    temperature: float,\n):\n    \"\"\"\n    Sets the desired temperature when in manual mode. The temperature is only taken into account if the room is in\n    MANUAL mode, otherwise it has no effect.\n\n    Parameters:\n        room: The target room\n        temperature: The target temperature\n    \"\"\"\n    logger.debug(\n        \"Setting manual mode setpoint temperature to %.1f for %s\",\n        temperature,\n        room.name,\n    )\n    payload: dict[str, Any] = {\n        \"temperatureSetpoint\": temperature,\n    }\n    url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/temperature-setpoint\"\n\n    await self.aiohttp_session.put(\n        url,\n        json=payload,\n        headers=self.get_authorized_headers(),\n    )\n    room.room_configuration.temperature_setpoint = temperature\n    return room\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_ambisense_room_operation_mode","title":"<code>set_ambisense_room_operation_mode(room, mode)</code>  <code>async</code>","text":"<p>Sets the operation mode for a room</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>AmbisenseRoom</code> <p>The room</p> required <code>mode</code> <code>AmbisenseRoomOperationMode | str</code> <p>The operation mode</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ambisense_room_operation_mode(\n    self,\n    room: AmbisenseRoom,\n    mode: AmbisenseRoomOperationMode | str,\n) -&gt; AmbisenseRoom:\n    \"\"\"\n    Sets the operation mode for a room\n\n    Parameters:\n        room: The room\n        mode: The operation mode\n    \"\"\"\n    url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/configuration/operation-mode\"\n    await self.aiohttp_session.put(\n        url,\n        json={\"operationMode\": str(mode).lower()},\n        headers=self.get_authorized_headers(),\n    )\n\n    if isinstance(mode, str):\n        room.room_configuration.operation_mode = AmbisenseRoomOperationMode(\n            mode.upper()\n        )\n    else:\n        room.room_configuration.operation_mode = mode\n    return room\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_ambisense_room_time_program","title":"<code>set_ambisense_room_time_program(room, time_program)</code>  <code>async</code>","text":"<p>Set time program for an ambisense room</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>AmbisenseRoom</code> <p>The target room</p> required <code>time_program</code> <code>RoomTimeProgram</code> <p>The new time program</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ambisense_room_time_program(\n    self, room: AmbisenseRoom, time_program: RoomTimeProgram\n) -&gt; AmbisenseRoom:\n    \"\"\"\n    Set time program for an ambisense room\n\n    Parameters:\n        room: The target room\n        time_program: The new time program\n    \"\"\"\n    url = f\"{await self.get_api_base()}/api/v1/ambisense/facilities/{room.system_id}/rooms/{room.room_index}/timeprogram\"\n\n    data = asdict(time_program, dict_factory=RoomTimeProgram.dict_factory)\n    payload = dict_to_camel_case(data)\n\n    await self.aiohttp_session.put(\n        url, json=payload, headers=self.get_authorized_headers()\n    )\n    room.time_program = time_program\n    return room\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_circuit_heat_demand_limited_by_outside_temperature","title":"<code>set_circuit_heat_demand_limited_by_outside_temperature(circuit, heat_demand_limited_by_outside_temperature)</code>  <code>async</code>","text":"<p>Set heating curve value for a circuit</p> <p>:param circuit: :param heat_demand_limited_by_outside_temperature: :return:</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_circuit_heat_demand_limited_by_outside_temperature(\n    self,\n    circuit: Circuit,\n    heat_demand_limited_by_outside_temperature: float,\n) -&gt; Circuit:\n    \"\"\"\n    Set heating curve value for a circuit\n\n    :param circuit:\n    :param heat_demand_limited_by_outside_temperature:\n    :return:\n    \"\"\"\n    url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/heat-demand-limited-by-outside-temperature\"\n\n    await self.aiohttp_session.post(\n        url,\n        json={\n            \"heatDemandLimitedByOutsideTemperature\": heat_demand_limited_by_outside_temperature\n        },\n        headers=self.get_authorized_headers(),\n    )\n    circuit.heat_demand_limited_by_outside_temperature = (\n        heat_demand_limited_by_outside_temperature\n    )\n    return circuit\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_circuit_heating_curve","title":"<code>set_circuit_heating_curve(circuit, heating_curve)</code>  <code>async</code>","text":"<p>Set heating curve value for a circuit</p> <p>:param circuit: :param heating_curve: :return:</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_circuit_heating_curve(\n    self,\n    circuit: Circuit,\n    heating_curve: float,\n) -&gt; Circuit:\n    \"\"\"\n    Set heating curve value for a circuit\n\n    :param circuit:\n    :param heating_curve:\n    :return:\n    \"\"\"\n    url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/heating-curve\"\n\n    await self.aiohttp_session.patch(\n        url,\n        json={\"heatingCurve\": heating_curve},\n        headers=self.get_authorized_headers(),\n    )\n    circuit.heating_curve = heating_curve\n    return circuit\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_circuit_min_flow_temperature_setpoint","title":"<code>set_circuit_min_flow_temperature_setpoint(circuit, min_flow_temperature_setpoint)</code>  <code>async</code>","text":"<p>Set heating curve value for a circuit</p> <p>:param circuit: :param min_flow_temperature_setpoint: :return:</p> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_circuit_min_flow_temperature_setpoint(\n    self,\n    circuit: Circuit,\n    min_flow_temperature_setpoint: float,\n) -&gt; Circuit:\n    \"\"\"\n    Set heating curve value for a circuit\n\n    :param circuit:\n    :param min_flow_temperature_setpoint:\n    :return:\n    \"\"\"\n    url = f\"{await self.get_system_api_base(circuit.system_id)}/circuit/{circuit.index}/min-flow-temperature-setpoint\"\n\n    await self.aiohttp_session.patch(\n        url,\n        json={\"minFlowTemperatureSetpoint\": min_flow_temperature_setpoint},\n        headers=self.get_authorized_headers(),\n    )\n    circuit.heating_flow_temperature_minimum_setpoint = (\n        min_flow_temperature_setpoint\n    )\n    return circuit\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_cooling_for_days","title":"<code>set_cooling_for_days(system, start=None, end=None, duration_days=None)</code>  <code>async</code>","text":"<p>Sets cooling for a number of days</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The target system</p> required <code>start</code> <code>datetime | None</code> <p>Optional, datetime when the system goes into cooling mode. Defaults to now</p> <code>None</code> <code>end</code> <code>datetime | None</code> <p>Optional, datetime when cooling mode should end. Defaults to one year from now</p> <code>None</code> <code>duration_days</code> <code>int | None</code> <p>Optional, number of days to cool</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_cooling_for_days(\n    self,\n    system: System,\n    start: datetime.datetime | None = None,\n    end: datetime.datetime | None = None,\n    duration_days: int | None = None,\n):\n    \"\"\"\n    Sets cooling for a number of days\n\n    Parameters:\n        system: The target system\n        start: Optional, datetime when the system goes into cooling mode. Defaults to now\n        end: Optional, datetime when cooling mode should end. Defaults to one year from now\n        duration_days: Optional, number of days to cool\n    \"\"\"\n    data: dict[str, int | str] = {}\n    if system.control_identifier.is_vrc700:\n        if not duration_days:\n            raise ValueError(\"duration_days is required on VRC700 controllers\")\n        if start or end:\n            raise ValueError(\n                \"Start and end dates are not supported on VRC700 controllers, use duration_days instead\"\n            )\n        data[\"value\"] = duration_days\n    else:\n        if duration_days:\n            if start or end:\n                raise ValueError(\n                    \"Start and end dates can't be used together with duration_days\"\n                )\n            start = datetime.datetime.now(system.timezone)\n            end = start + datetime.timedelta(days=duration_days)\n        else:\n            start, end = get_default_holiday_dates(start, end, system.timezone)\n        if not start &lt;= end:\n            raise ValueError(\"Start of holiday mode must be before end\")\n        data[\"startDateTime\"] = datetime_format(start, with_microseconds=True)\n        data[\"endDateTime\"] = datetime_format(end, with_microseconds=True)\n\n    logger.debug(\n        \"Setting cooling for days on system %s with data %s\", system.id, data\n    )\n\n    await self.aiohttp_session.post(\n        f\"{await self.get_system_api_base(system.id)}/cooling-for-days\",\n        json=data,\n        headers=self.get_authorized_headers(),\n    )\n\n    if start and end:\n        system.configuration[\"system\"][\"manual_cooling_start_date\"] = (\n            datetime_format(start)\n        )\n        system.configuration[\"system\"][\"manual_cooling_end_date\"] = datetime_format(\n            end\n        )\n    if system.control_identifier.is_vrc700:\n        system.configuration[\"system\"][\"cooling_for_x_days\"] = duration_days\n    return system\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_circulation_time_program","title":"<code>set_domestic_hot_water_circulation_time_program(domestic_hot_water, time_program)</code>  <code>async</code>","text":"<p>Sets the schedule for the water circulation pump</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>time_program</code> <code>DHWTimeProgram</code> <p>The schedule</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_circulation_time_program(\n    self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n):\n    \"\"\"\n    Sets the schedule for the water circulation pump\n\n    Parameters:\n        domestic_hot_water: The water heater\n        time_program: The schedule\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/circulation-pump-time-windows\"\n    )\n    data = asdict(time_program)\n    del data[\"meta_info\"]\n    await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n    domestic_hot_water.time_program_circulation_pump = time_program\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_operation_mode","title":"<code>set_domestic_hot_water_operation_mode(domestic_hot_water, mode)</code>  <code>async</code>","text":"<p>Sets the operation mode for water heating</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>mode</code> <code>DHWOperationMode | DHWOperationModeVRC700 | str</code> <p>The operation mode</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_operation_mode(\n    self,\n    domestic_hot_water: DomesticHotWater,\n    mode: DHWOperationMode | DHWOperationModeVRC700 | str,\n):\n    \"\"\"\n    Sets the operation mode for water heating\n\n    Parameters:\n        domestic_hot_water: The water heater\n        mode: The operation mode\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}/domestic-hot-water/\"\n        f\"{domestic_hot_water.index}/operation-mode\"\n    )\n    await self.aiohttp_session.patch(\n        url,\n        json={\"operationMode\": str(mode)},\n        headers=self.get_authorized_headers(),\n    )\n\n    if isinstance(mode, str):\n        if domestic_hot_water.control_identifier.is_vrc700:\n            mode = DHWOperationModeVRC700(mode)\n        else:\n            mode = DHWOperationMode(mode)\n    domestic_hot_water.operation_mode_dhw = mode\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_temperature","title":"<code>set_domestic_hot_water_temperature(domestic_hot_water, temperature)</code>  <code>async</code>","text":"<p>Sets the desired hot water temperature</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>temperature</code> <code>int | float</code> <p>The desired temperature, only whole numbers are supported by the API, floats get rounded</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_temperature(\n    self, domestic_hot_water: DomesticHotWater, temperature: int | float\n):\n    \"\"\"\n    Sets the desired hot water temperature\n\n    Parameters:\n        domestic_hot_water: The water heater\n        temperature: The desired temperature, only whole numbers are supported by the API, floats get rounded\n    \"\"\"\n    if isinstance(temperature, float):\n        logger.warning(\"Domestic hot water can only be set to whole numbers\")\n        temperature = int(round(temperature, 0))\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/temperature\"\n    )\n    await self.aiohttp_session.patch(\n        url, json={\"setpoint\": temperature}, headers=self.get_authorized_headers()\n    )\n    domestic_hot_water.tapping_setpoint = temperature\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_domestic_hot_water_time_program","title":"<code>set_domestic_hot_water_time_program(domestic_hot_water, time_program)</code>  <code>async</code>","text":"<p>Sets the schedule for heating water</p> <p>Parameters:</p> Name Type Description Default <code>domestic_hot_water</code> <code>DomesticHotWater</code> <p>The water heater</p> required <code>time_program</code> <code>DHWTimeProgram</code> <p>The schedule</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_domestic_hot_water_time_program(\n    self, domestic_hot_water: DomesticHotWater, time_program: DHWTimeProgram\n):\n    \"\"\"\n    Sets the schedule for heating water\n\n    Parameters:\n        domestic_hot_water: The water heater\n        time_program: The schedule\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(domestic_hot_water.system_id)}\"\n        f\"/domestic-hot-water/{domestic_hot_water.index}/time-windows\"\n    )\n    data = asdict(time_program)\n    del data[\"meta_info\"]\n    await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n    domestic_hot_water.time_program_dhw = time_program\n    return domestic_hot_water\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_holiday","title":"<code>set_holiday(system, start=None, end=None, setpoint=None)</code>  <code>async</code>","text":"<p>Sets away mode / holiday mode on a system</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>The target system</p> required <code>start</code> <code>datetime | None</code> <p>Optional, datetime when the system goes into away mode. Defaults to now</p> <code>None</code> <code>end</code> <code>datetime | None</code> <p>Optional, datetime when away mode should end. Defaults to one year from now</p> <code>None</code> <code>setpoint</code> <code>float | None</code> <p>Optional, setpoint temperature during holiday, only supported on VRC700 controllers</p> <code>None</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_holiday(\n    self,\n    system: System,\n    start: datetime.datetime | None = None,\n    end: datetime.datetime | None = None,\n    setpoint: float | None = None,\n):\n    \"\"\"\n    Sets away mode / holiday mode on a system\n\n    Parameters:\n        system: The target system\n        start: Optional, datetime when the system goes into away mode. Defaults to now\n        end: Optional, datetime when away mode should end. Defaults to one year from now\n        setpoint: Optional, setpoint temperature during holiday, only supported on VRC700 controllers\n    \"\"\"\n    start, end = get_default_holiday_dates(start, end, system.timezone)\n    logger.debug(\n        \"Setting holiday mode for system %s to %s - %s\", system.id, start, end\n    )\n    if not start &lt;= end:\n        raise ValueError(\"Start of holiday mode must be before end\")\n\n    data = {\n        \"startDateTime\": datetime_format(start, with_microseconds=True),\n        \"endDateTime\": datetime_format(end, with_microseconds=True),\n    }\n\n    if system.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(system.id)}/holiday\"\n        if setpoint is None:\n            raise ValueError(\"setpoint is required on this controller\")\n        data[\"setpoint\"] = setpoint  # type: ignore\n    else:\n        url = f\"{await self.get_system_api_base(system.id)}/away-mode\"\n        if setpoint is not None:\n            raise ValueError(\"setpoint is not supported on this controller\")\n\n    await self.aiohttp_session.post(\n        url, json=data, headers=self.get_authorized_headers()\n    )\n    for zone in system.zones:\n        zone.current_special_function = ZoneCurrentSpecialFunction.HOLIDAY\n        zone.general.holiday_start_date_time = start\n        zone.general.holiday_end_date_time = end\n    return system\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_manual_mode_setpoint","title":"<code>set_manual_mode_setpoint(zone, temperature, setpoint_type='heating')</code>  <code>async</code>","text":"<p>Sets the desired temperature when in manual mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The target temperature</p> required <code>setpoint_type</code> <code>str | ZoneOperatingType</code> <p>Either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_manual_mode_setpoint(\n    self,\n    zone: Zone,\n    temperature: float,\n    setpoint_type: str | ZoneOperatingType = \"heating\",\n):\n    \"\"\"\n    Sets the desired temperature when in manual mode\n\n    Parameters:\n        zone: The target zone\n        temperature: The target temperature\n        setpoint_type: Either heating or cooling\n    \"\"\"\n    logger.debug(\"Setting manual mode setpoint for %s\", zone.name)\n    if setpoint_type not in ZoneOperatingType:\n        raise ValueError(\n            f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n        )\n    setpoint_type = str(setpoint_type).lower()\n    payload: dict[str, Any] = {\n        \"setpoint\": temperature,\n    }\n    if zone.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setpoint_type}/manual-mode-setpoint\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/manual-mode-setpoint\"\n        payload[\"type\"] = setpoint_type.upper()\n    await self.aiohttp_session.patch(\n        url,\n        json=payload,\n        headers=self.get_authorized_headers(),\n    )\n    # zone.heating.manual_mode_setpoint_heating or zone.cooling.manual_mode_setpoint_cooling\n    setattr(\n        getattr(zone, setpoint_type.lower()),\n        f\"manual_mode_setpoint_{setpoint_type}\",\n        temperature,\n    )\n\n    if (\n        setpoint_type == \"cooling\"\n        and zone.cooling\n        and zone.cooling.operation_mode_cooling == ZoneOperatingMode.MANUAL\n    ):\n        zone.desired_room_temperature_setpoint_cooling = temperature\n\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_set_back_temperature","title":"<code>set_set_back_temperature(zone, temperature, setback_type='heating')</code>  <code>async</code>","text":"<p>Sets the temperature that a zone gets lowered to in away mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>temperature</code> <code>float</code> <p>The setback temperature</p> required <code>setback_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_set_back_temperature(\n    self, zone: Zone, temperature: float, setback_type: str = \"heating\"\n):\n    \"\"\"\n    Sets the temperature that a zone gets lowered to in away mode\n\n    Parameters:\n        zone: The target zone\n        temperature: The setback temperature\n        setback_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if zone.control_identifier.is_vrc700:\n        if setback_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid setback type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/set-back-temperature\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/set-back-temperature\"\n    await self.aiohttp_session.patch(\n        url,\n        json={\"setBackTemperature\": temperature},\n        headers=self.get_authorized_headers(),\n    )\n    # TODO: What to do with cooling?\n    if setback_type == \"heating\":\n        zone.heating.set_back_temperature = temperature\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_ventilation_fan_stage","title":"<code>set_ventilation_fan_stage(ventilation, maximum_fan_stage, fan_stage_type)</code>  <code>async</code>","text":"<p>Sets the maximum fan stage for a stage type</p> <p>Parameters:</p> Name Type Description Default <code>ventilation</code> <code>Ventilation</code> <p>The ventilation device</p> required <code>maximum_fan_stage</code> <code>int</code> <p>The maximum fan speed, from 1-6</p> required <code>fan_stage_type</code> <code>VentilationFanStageType</code> <p>The fan stage type (day or night)</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ventilation_fan_stage(\n    self,\n    ventilation: Ventilation,\n    maximum_fan_stage: int,\n    fan_stage_type: VentilationFanStageType,\n):\n    \"\"\"\n    Sets the maximum fan stage for a stage type\n\n    Parameters:\n        ventilation: The ventilation device\n        maximum_fan_stage: The maximum fan speed, from 1-6\n        fan_stage_type: The fan stage type (day or night)\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(ventilation.system_id)}\"\n        f\"/ventilation/{ventilation.index}/fan-stage\"\n    )\n    await self.aiohttp_session.patch(\n        url,\n        json={\n            \"maximumFanStage\": maximum_fan_stage,\n            \"type\": str(fan_stage_type),\n        },\n        headers=self.get_authorized_headers(),\n    )\n    setattr(\n        ventilation,\n        f\"maximum_{fan_stage_type.lower()}_fan_stage\",\n        maximum_fan_stage,\n    )\n    return ventilation\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_ventilation_operation_mode","title":"<code>set_ventilation_operation_mode(ventilation, mode)</code>  <code>async</code>","text":"<p>Sets the operation mode for a ventilation device</p> <p>Parameters:</p> Name Type Description Default <code>ventilation</code> <code>Ventilation</code> <p>The ventilation device</p> required <code>mode</code> <code>VentilationOperationMode | VentilationOperationModeVRC700</code> <p>The operation mode</p> required Source code in <code>myPyllant/api.py</code> <pre><code>async def set_ventilation_operation_mode(\n    self,\n    ventilation: Ventilation,\n    mode: VentilationOperationMode | VentilationOperationModeVRC700,\n):\n    \"\"\"\n    Sets the operation mode for a ventilation device\n\n    Parameters:\n        ventilation: The ventilation device\n        mode: The operation mode\n    \"\"\"\n    url = (\n        f\"{await self.get_system_api_base(ventilation.system_id)}\"\n        f\"/ventilation/{ventilation.index}/operation-mode\"\n    )\n    await self.aiohttp_session.patch(\n        url,\n        json={\n            \"operationMode\": str(mode),\n        },\n        headers=self.get_authorized_headers(),\n    )\n    ventilation.operation_mode_ventilation = mode\n    return ventilation\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_zone_operating_mode","title":"<code>set_zone_operating_mode(zone, mode, operating_type='heating')</code>  <code>async</code>","text":"<p>Sets the operating mode for a zone</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>mode</code> <code>ZoneOperatingMode | ZoneOperatingModeVRC700 | str</code> <p>The target operating mode</p> required <code>operating_type</code> <code>str</code> <p>Either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_zone_operating_mode(\n    self,\n    zone: Zone,\n    mode: ZoneOperatingMode | ZoneOperatingModeVRC700 | str,\n    operating_type: str = \"heating\",\n):\n    \"\"\"\n    Sets the operating mode for a zone\n\n    Parameters:\n        zone: The target zone\n        mode: The target operating mode\n        operating_type: Either heating or cooling\n    \"\"\"\n    payload = {}\n    operating_type = operating_type.lower()\n    if operating_type not in ZoneOperatingType:\n        raise ValueError(\n            f\"Invalid HVAC mode, must be one of {', '.join(ZoneOperatingType)}\"\n        )\n    if zone.control_identifier.is_vrc700:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{operating_type}/operation-mode\"\n        mode_enum = ZoneOperatingModeVRC700  # type: ignore\n    else:\n        if operating_type == \"cooling\":\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/operation-mode\"\n            payload[\"type\"] = operating_type.upper()\n        else:\n            url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/{operating_type}-operation-mode\"\n        mode_enum = ZoneOperatingMode  # type: ignore\n\n    if mode not in mode_enum:\n        raise ValueError(\n            f\"Invalid mode, must be one of {', '.join(mode_enum.__members__)}\"\n        )\n\n    payload[\"operationMode\"] = str(mode)\n\n    await self.aiohttp_session.patch(\n        url,\n        json=payload,\n        headers=self.get_authorized_headers(),\n    )\n\n    # zone.heating.operation_mode_heating or zone.cooling.operation_mode_cooling\n    setattr(\n        getattr(zone, operating_type),\n        f\"operation_mode_{operating_type}\",\n        mode_enum(mode),\n    )\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.set_zone_time_program","title":"<code>set_zone_time_program(zone, program_type, time_program, setback_type='heating')</code>  <code>async</code>","text":"<p>Sets the temperature that a zone gets lowered to in away mode</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Zone</code> <p>The target zone</p> required <code>program_type</code> <code>str</code> <p>Which program to set</p> required <code>time_program</code> <code>ZoneTimeProgram</code> <p>The time schedule</p> required <code>setback_type</code> <code>str</code> <p>Only supported on VRC700 controllers, either heating or cooling</p> <code>'heating'</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def set_zone_time_program(\n    self,\n    zone: Zone,\n    program_type: str,\n    time_program: ZoneTimeProgram,\n    setback_type: str = \"heating\",\n):\n    \"\"\"\n    Sets the temperature that a zone gets lowered to in away mode\n\n    Parameters:\n        zone: The target zone\n        program_type: Which program to set\n        time_program: The time schedule\n        setback_type: Only supported on VRC700 controllers, either heating or cooling\n    \"\"\"\n    if program_type not in ZoneOperatingType:\n        raise ValueError(\n            \"Type must be either heating or cooling, not %s\", program_type\n        )\n    if zone.control_identifier.is_vrc700:\n        if setback_type not in ZoneOperatingType:\n            raise ValueError(\n                f\"Invalid veto type, must be one of {', '.join(ZoneOperatingType)}\"\n            )\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zone/{zone.index}/{setback_type}/time-windows\"\n    else:\n        url = f\"{await self.get_system_api_base(zone.system_id)}/zones/{zone.index}/time-windows\"\n    data = asdict(time_program)\n    data[\"type\"] = program_type\n    del data[\"meta_info\"]\n    await self.aiohttp_session.patch(\n        url,\n        json=dict_to_camel_case(data),\n        headers=self.get_authorized_headers(),\n    )\n\n    # zone.heating.time_program_heating = time_program or zone.cooling.time_program_cooling = time_program\n    setattr(\n        getattr(zone, setback_type), f\"time_program_{setback_type}\", time_program\n    )\n    return zone\n</code></pre>"},{"location":"3-library/#myPyllant.api.MyPyllantAPI.toggle_eebus","title":"<code>toggle_eebus(system, enabled=True)</code>  <code>async</code>","text":"<p>Enables EEBUS interface</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System | str</code> <p>The System object or system ID string</p> required <code>enabled</code> <code>bool</code> <p>Whether to enable or disable EEBUS</p> <code>True</code> Source code in <code>myPyllant/api.py</code> <pre><code>async def toggle_eebus(\n    self, system: System | str, enabled: bool = True\n) -&gt; System | None:\n    \"\"\"\n    Enables EEBUS interface\n\n    Parameters:\n        system: The System object or system ID string\n        enabled: Whether to enable or disable EEBUS\n    \"\"\"\n    await self.aiohttp_session.put(\n        f\"{await self.get_api_base()}/ship/{get_system_id(system)}/self/spine\",\n        json={\"enabled\": enabled},\n        headers=self.get_authorized_headers(),\n    )\n    if isinstance(system, System) and system.eebus:\n        system.eebus[\"spline_enabled\"] = enabled\n        return system\n    return None\n</code></pre>"},{"location":"3-reverse-engineering/","title":"Reverse Engineering Android Apps","text":""},{"location":"3-reverse-engineering/#reverse-engineering-android-apps","title":"Reverse Engineering Android Apps","text":"<p>Any Android app that makes HTTPS API requests (in this case to the myVAILLANT API), can be reverse engineered with an Android device and a laptop / PC that runs ADB. Both need to be on the same network. Creating a hotspot from the Android device also works.</p> <ol> <li>Run mitmproxy on your laptop, for example in Docker:     <pre><code>docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -p 0.0.0.0:8080:8080 -p 127.0.0.1:8081:8081 mitmproxy/mitmproxy mitmweb --web-host 0.0.0.0\n</code></pre></li> <li>In your Android WI-FI settings (see screenshot below) set a manual proxy to the IP of the device running mitmproxy on port 8080.    Add a bypass for <code>identity.vaillant-group.com</code><sup>1</sup></li> <li>Visit mitm.it on your Android device, download the CA cert &amp; install it through the settings app</li> <li>Install ADB on your laptop and connect your Android device to USB in debug mode</li> <li>Look for the myVAILLANT APK online and download it</li> <li>Install &amp; run apk-mitm on the APK and install it with adb:</li> </ol> apkxapk <pre><code>apk-mitm myVAILLANT.apk\nadb install myVAILLANT-patched.apk\n</code></pre> <pre><code>apk-mitm myVAILLANT.xapk\nunzip ./myVAILLANT-patched.xapk\nadb install-multiple com.vaillantgroup.enduserapp.vaillant.apk config.mdpi.apk config.fr.apk config.en.apk config.arm64_v8a.apk\n</code></pre> <p>You should see all API calls in mitmproxy's web interface on http://127.0.0.1:8081 now. </p> <p>Note</p> <p>If you can't log in with SSO because of a certificate error, make sure you added the exception to the proxy settings.</p> <p>If you can log in, but the app reports an error, the unpinning didn't work. You can try MagiskTrustUserCertson if you have a rooted Android device.</p> <p> </p> Source: digitalcitizen.life <ol> <li> <p>The single-sign on gets handled in your browser, which uses certificate pinning as an added security measure\u00a0\u21a9</p> </li> </ol>"}]}